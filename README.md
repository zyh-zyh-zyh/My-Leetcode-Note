# 📝My LeetCode Note

## 🗺️路线

* [🔢数组](#数-组) --> [⛓️链表](#%EF%B8%8F链-表) --> [🧾哈希表](#哈-希-表) --> [🔡字符串](#字-符-串) --> [🈯️双指针法](#%EF%B8%8F双-指-针-法)  --> [🎢栈与队列](#栈-与-队-列) --> [🌳树](#树) --> [🔙回溯](#回-溯) --> [💯贪心](#贪-心) --> [📡动态规划](#动-态-规-划) --> [🧩图论](#图-论) --> [🎯高级数据结构](#高-级-数-据-结-构)

按题型刷完后，再从`简单`刷起，做了几个类型题目之后，再慢慢做`中等`题目、`困难`题目。

* 路线 from：[代码随想录](https://programmercarl.com/)

* 题解语言：`Java`

&nbsp;

---
&nbsp;

## 🔢数 组

### 27. 移除元素

* **【TODO】**

### 26. 删除排序数组中的重复项

* **【TODO】**

### 283. 移动零

* **【TODO】**

### [844. 比较含退格的字符串](./Solutions/844.比较含退格的字符串.md)

### [977. 有序数组的平方](./Solutions/977.有序数组的平方.md)

### [209. 长度最小的子数组](./Solutions/209.长度最小的子数组.md)

### [904. 水果成篮](./Solutions/904.水果成篮.md)

### [76. 最小覆盖子串](./Solutions/76.最小覆盖子串.md)

### [59. 螺旋矩阵 II](./Solutions/59.螺旋矩阵II.md)

&nbsp;

---

&nbsp;

## ⛓️链 表

### [203. 移除链表元素](./Solutions/203.移除链表元素.md)

### [707. 设计链表](./Solutions/707.设计链表.md)

### [206. 反转链表](./Solutions/206.反转链表.md)

### [24. 两两交换链表中的节点](./Solutions/24.两两交换链表中的节点.md)

### [19. 删除链表的倒数第 N 个结点](./Solutions/19.删除链表的倒数第N个结点.md)

### [面试题 02.07. 链表相交](./Solutions/面试题02.07.链表相交.md)

### [142. 环形链表II](./Solutions/142.环形链表II.md)

&nbsp;

---

&nbsp;

## 🧾哈 希 表

### 基础：

**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法**。

但是哈希法也是**牺牲了空间换取了时间**，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。

如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！

[( from 代码随想录 哈希表理论基础 )](https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%89%E7%A7%8D%E5%93%88%E5%B8%8C%E7%BB%93%E6%9E%84)

&nbsp;

### [242. 有效的字母异位词](./Solutions/242.有效的字母异位词.md)

### [383. 赎金信](./Solutions/383.赎金信.md)

### [49. 字母异位词分组](./Solutions/49.字母异位词分组.md)

### [438. 找到字符串中所有字母异位词](./Solutions/438.找到字符串中所有字母异位词.md)

### [349. 两个数组的交集](./Solutions/350.两个数组的交集II.md)

### [202. 快乐数](./Solutions/202.快乐数.md)

### 1. 两数之和

* **【TODO】**

### [454. 四数相加II](./Solutions/454.四数相加II.md)

### [15. 三数之和](./Solutions/15.三数之和.md)

### 18. 四数之和

* **【TODO】**

&nbsp;

---

&nbsp;

## 🔡字 符 串

### 344. 反转字符串

* **【TODO】**

### [541. 反转字符串II](./Solutions/541.反转字符串II.md)

### [剑指Offer 05. 替换空格](./Solutions/剑指Offer05.替换空格.md)

### [151. 翻转字符串里的单词](./Solutions/151.翻转字符串里的单词.md)

### [剑指Offer58-II. 左旋转字符串](./Solutions/剑指Offer58-II.左旋转字符串.md)

### [28. 实现 strStr()](./Solutions/28.实现strStr().md)

### [459. 重复的子字符串](./Solutions/459.重复的子字符串.md)

&nbsp;

---

&nbsp;

## 🈯️双 指 针 法

### [27. 移除元素](./Solutions/27.移除元素.md)

### [344. 反转字符串](./Solutions/344.反转字符串.md)

### 151.翻转字符串里的单词

### 206.反转链表

### 19.删除链表的倒数第N个节点

### 面试题 02.07. 链表相交

### 142.环形链表II

### 15. 三数之和

### 18. 四数之和

&nbsp;

---

&nbsp;


## 🎢栈 与 队 列

### [232. 用栈实现队列](./Solutions/232.用栈实现队列.md)

### [225. 用队列实现栈](./Solutions/225.用队列实现栈.md)

### [20. 有效的括号](./Solutions/20.有效的括号.md)

### [1047. 删除字符串中的所有相邻重复项](./Solutions/1047.删除字符串中的所有相邻重复项.md)

### [150. 逆波兰表达式求值](./Solutions/150.逆波兰表达式求值.md)

### [239. 滑动窗口最大值](./Solutions/239.滑动窗口最大值.md)

### [347. 前K个高频元素](./Solutions/347.前K个高频元素.md)

### 栈与队列总结



* **【TODO】**

&nbsp;

---

&nbsp;

## 🌳树

### [144. 二叉树的前序遍历](./Solutions/144.二叉树的前序遍历.md)

### [145. 二叉树的后序遍历](./Solutions/145.二叉树的后序遍历.md)

### [94. 二叉树的中序遍历](./Solutions/94.二叉树的中序遍历.md)

### [102. 二叉树的层序遍历](./Solutions/102.二叉树的层序遍历.md)

### [226. 翻转二叉树](./Solutions/226.翻转二叉树.md)

### [101. 对称二叉树](./Solutions/101.对称二叉树.md)

### [104. 二叉树的最大深度](./Solutions/104.二叉树的最大深度.md)

### 559. n叉树的最大深度

### [111. 二叉树的最小深度](./Solutions/111.二叉树的最小深度.md)

### [222. 完全二叉树的节点个数](./Solutions/222.完全二叉树的节点个数.md)

### [110. 平衡二叉树](./Solutions/110.平衡二叉树.md)

### [257. 二叉树的所有路径](./Solutions/257.二叉树的所有路径.md)

### [404. 左叶子之和](./Solutions/404.左叶子之和.md)

### [513. 找树左下角的值](./Solutions/513.找树左下角的值.md)

### [112. 路径总和](./Solutions/112.路径总和.md)

### 106. 从中序与后序遍历序列构造二叉树

### [654. 最大二叉树](./Solutions/654.最大二叉树.md)

### [617. 合并二叉树](./Solutions/617.合并二叉树.md)

### 700. 二叉搜索树中的搜索

### 98. 验证二叉搜索树

### 530. 二叉搜索树的最小绝对差

### 501. 二叉搜索树中的众数

### 236. 二叉树的最近公共祖先

### 235. 二叉搜索树的最近公共祖先

```java

```

### 701. 二叉搜索树中的插入操作

### 450. 删除二叉搜索树中的节点

### 669. 修剪二叉搜索树

### 108.将有序数组转换为二叉搜索树

### 538.把二叉搜索树转换为累加树

&nbsp;

---

&nbsp;

## 🔙回 溯

&nbsp;

### 77. 组合

### 216. 组合总和 III

### 17. 电话号码的字母组合

### 39. 组合总和

### 40. 组合总和II

### 131. 分割回文串

### 93. 复原IP地址

### 78. 子集问题

### 90. 子集II

### 491. 递增子序列

### 46. 全排列

### 47. 全排列II

```java
class Solution {
    LinkedList<Integer> base = new LinkedList();
    ArrayList<List<Integer>> ans = new ArrayList();
    HashMap<Integer, Integer> map = new HashMap();
    HashMap<Integer, Integer> table = new HashMap();
    HashSet<Integer> set = new HashSet();
    HashSet<List<Integer>> dup = new HashSet();
    public List<List<Integer>> permuteUnique(int[] nums) {
        for (int n : nums) {
            table.put(n, table.getOrDefault(n, 0) + 1);
        }
        dfs(nums, 0);
        return ans;
    }

    public void dfs(int[] nums, int count) {
        //end condition
        if (count == nums.length) {
            if (!dup.contains(base)) {
                ans.add(new ArrayList(base));
                dup.add(new ArrayList(base));
            }
            return;    
        }

        //backTrace body
        for (int i = 0; i < nums.length; i++) {
            if (!map.containsKey(nums[i]) || table.get(nums[i]) != map.get(nums[i])) {
                base.add(nums[i]);
                map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);
                dfs(nums, count + 1);
                base.removeLast();
                map.put(nums[i], map.get(nums[i]) - 1);
            }
        }
    }
}
```

```java
class Solution {
    //存放结果
    List<List<Integer>> result = new ArrayList<>();
    //暂存结果
    List<Integer> path = new ArrayList<>();

    public List<List<Integer>> permuteUnique(int[] nums) {
        boolean[] used = new boolean[nums.length];
        Arrays.fill(used, false);
        Arrays.sort(nums);
        backTrack(nums, used);
        return result;
    }

    private void backTrack(int[] nums, boolean[] used) {
        if (path.size() == nums.length) {
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            // used[i - 1] == true，说明同⼀树⽀nums[i - 1]使⽤过
            // used[i - 1] == false，说明同⼀树层nums[i - 1]使⽤过
            // 如果同⼀树层nums[i - 1]使⽤过则直接跳过
            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {
                continue;
            }
            //如果同⼀树⽀nums[i]没使⽤过开始处理
            if (used[i] == false) {
                used[i] = true;//标记同⼀树⽀nums[i]使⽤过，防止同一树支重复使用
                path.add(nums[i]);
                backTrack(nums, used);
                path.remove(path.size() - 1);//回溯，说明同⼀树层nums[i]使⽤过，防止下一树层重复
                used[i] = false;//回溯
            }
        }
    }
}

作者：carlsun-2
链接：https://leetcode-cn.com/problems/permutations-ii/solution/dai-ma-sui-xiang-lu-dai-ni-xue-tou-hui-s-ki1h/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

### 332. 重新安排行程

```java

```

### 51. N皇后

```java

```

### 37. 解数独

```java

```

&nbsp;

---

&nbsp;

## 💯贪 心

&nbsp;

### 455. 分发饼干

```java
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        int count = 0;
        int j = 0;
        for (int i = 0; i < s.length && j < g.length; i++) {
            if (s[i] >= g[j]) {
                count++;
                j++;
            }
        }
        return count;
    }
}
```

### 376. 摆动序列

尝试回溯， **超时**：

```java
class Solution {
    int max = 0;
    public int wiggleMaxLength(int[] nums) {
        dfs(nums, 0, -1, -1, 0);
        return max;
    }
    //n2: 上一位 符合条件的 索引, -1 表示无
    //n1: 上上一位符合条件的索引, -1 表示无
    //index: 当前索引
    //count: 符合条件的序列长度
    public void dfs(int[] nums, int index, int n2, int n1, int count) {
        
        //end condition
        if (index == nums.length) {
            max = max < count ? count : max;
            return;
        }
        //剪枝
        if (count + nums.length - index < max) {
            return;
        }

        //backTrace
        //n2 == -1，序列为空
        if (n2 == -1) {
            dfs(nums, index + 1, index, -1, 1);
            dfs(nums, index + 1, -1, -1, 0);
        }
        else {
            //n1 == -1，序列只有一位
            if (n1 == -1) {
                //序列添加第二位时 只需要与第一位不相等即可
                if (nums[n2] != nums[index]) {
                    dfs(nums, index + 1, index, n2, 2);
                }
            dfs(nums, index + 1, n2, -1, 1);

            }
            //index 的前两位差值为正数
            else if (nums[n2] - nums[n1] > 0) {
                if (nums[index] - nums[n2] < 0) {
                    dfs(nums, index + 1, index, n2, count + 1);
                }
                dfs(nums, index + 1, n2, n1, count);
            }
            //index 的前两位差值为负数
            else if (nums[n2] - nums[n1] < 0) {
                if (nums[index] - nums[n2] > 0) {
                    dfs(nums, index + 1, index, n2, count + 1);
                }
                dfs(nums, index + 1, n2, n1, count);
            }
        }
    }
}
```

* 内存超出限制

```java
class Solution {
    Queue<boolean[]> que = new LinkedList();
    public int wiggleMaxLength(int[] nums) {
        boolean[] isMark = new boolean[nums.length];
        Arrays.fill(isMark, true);
        que.add(isMark);
        return bfs(nums);
    }

    public int bfs(int[] nums) {
        int count = 0;
        while (!que.isEmpty()) {
            boolean[] cur = que.remove();
            //已找到
            if (isWiggle(nums, cur)) {
                count = 0;
                for (boolean mark : cur) {
                    if (mark) { count++; }
                }
                return count;
            }
            //该组合cur不是答案，在cur基础上添加下一层的 isMark 表
            for (int i = 0; i < nums.length; i++) {
                if (cur[i]) {
                    boolean[] tmp = Arrays.copyOf(cur, cur.length);
                    tmp[i] = false;
                    que.add(tmp);
                }
            }
        }
        return count;
    }

    public boolean isWiggle(int[] nums, boolean[] isMark) {
        int n1 = -1;
        int n2 = -1;
        //get first index
        for (int i = 0; i < isMark.length; i++) {
            //find first n1
            if (n1 == -1) {
                if (isMark[i]) {
                    n1 = i;
                    continue;
                }
            }
            //find first n2
            else if (n2 == -1) {
                if (isMark[i]) {
                    n2 = i;
                    break;
                }
            }            
        }
        if (n2 == -1) { return true; }
        else if (nums[n1] == nums[n2]) { return false; }

        for (int i = n2 + 1; i < isMark.length; i++) {
            if (isMark[i]) {
                if (nums[i] == nums[n2]) { return false; }
                if (nums[n2] > nums[n1] && nums[i] > nums[n2]) {
                    return false;
                }
                if (nums[n2] < nums[n1] && nums[i] < nums[n2]) {
                    return false;
                }
                n1 = n2;
                n2 = i;
            }
        }
        return true;
    }
}
```

### 53. 最大子序和

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int len = nums.length;
        if (len == 1) { return nums[0]; }

        int[] comb = new int[len];
        int index = 0;
        for (int i = 0; i < len; i++) {
            if (nums[i] == 0) {
                for (i; i < len; i++) {
                    if (nums[i] == 0) {
                        continue;
                    }
                    else {
                        comb[index++] = 0;
                        i--;
                    }
                }
            }
            else if (nums[i] > 0) {
               int sum = nums[i];
               for (i; i < len; i++) {
                   if (nums[i] >= 0) {
                       sum += nums[i];
                   }
                   else {
                       comb[index++] = sum;
                       i--;
                       continue;
                   }
               }
            }
            else if (nums[i] < 0) {
                int sum = nums[i];
                for (i; i < len; i++) {
                    if (nums[i] < 0) {
                        sum += nums[i];
                   }
                   else {
                       comb[index++] = sum;
                       i--;
                       continue;
                   }
               }
            }
        }
         int max = comb[0];
         int start = 0;
        if (comb[start] == 0) {
                i++;
                j++;
                if (comb[start] < 0) {
                    i++;
                    j++;
                }
            }
         for (int i = 0, int j = 0; i <= index, j <= index; i++, j++) {
            
        }



    }
}
```

超时

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int len = nums.length;
        if (len == 1) { return nums[0]; }
        
        int max = nums[0];
        int[] comb = new int[len];
        int index = 0;
        //求和：将相邻正数合并为一个数，相邻负数合并为一个数
        for (int i = 0; i < len; i++) {
            if (nums[i] == 0) {
                for ( ; i < len; i++) {
                    if (nums[i] == 0) {
                        max = Math.max(nums[i], max);
                        continue;
                    }
                    else {
                        comb[index] = 0;
                        index++;
                        i--;
                        break;
                    }
                }
            }
            else if (nums[i] > 0) {
                for ( ; i < len; i++) {
                    if (nums[i] >= 0) {
                        comb[index] += nums[i];
                        max = Math.max(nums[i], max);
                    }
                    else {
                        index++;
                        i--;
                        break;
                   }
               }
            }
            else if (nums[i] < 0) {
                for ( ; i < len; i++) {
                    if (nums[i] < 0) {
                        comb[index] += nums[i];
                        max = Math.max(nums[i], max);
                    }
                    else {
                        index++;
                        i--;
                        break;
                    }
                }
            }
        }

        int sum;
        for (int i = 0; i <= index; i++) {
            sum = 0;
            for (int j = i; j <= index; j++) {
                sum += comb[j];
                max = Math.max(sum, max);
            }
        }
        return max;
    }
}
```

DP

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int len = nums.length;
        if (len == 1) { return nums[0]; }

        int[] dp = new int[len];
        dp[0] = nums[0];
        int sum = nums[0];
        for (int i = 1; i < len; i++) {
            dp[i] = Math.max(nums[i] + dp[i - 1], nums[i]);
        }
        int max = dp[0];
        for (int x : dp) {
            max = Math.max(max, x);
        }
        return max;
    }
}
```

### 122. 买卖股票的最佳时机II

```java
class Solution {
    public int maxProfit(int[] prices) {
        int len = prices.length;
        if (len == 1) { return 0; }
        //判断是为否单调递减数组
        boolean isDes = true;
        for (int i = 1; i < len; i++) {
            if (prices[i] > prices[i - 1]) {
                isDes = false;
                break;
            }
        }
        //单调递减 最大利润为0
        if (isDes) { return 0; }

        //earning[] 表示 今天比上一天的收益
        int[] earning = new int[len];
        earning[0] = 0;
        int sum = 0;
        for (int i = 1; i < len; i++) {
            //记录所有的比上一天大的差值 若小于 则卖掉 故不用记录到sum中
            if (prices[i] >= prices[i - 1]) {
                earning[i] = prices[i] - prices[i - 1];
                sum += earning[i];
            }
        }
        return sum;
    }
}
```

### 55. 跳跃游戏

```java
class Solution {
    public boolean canJump(int[] nums) {
        int len = nums.length;
        if (len == 1) { return true; }
        int curLong = 0;
        int max = 0;
        for (int i = 0; i < len; i++) {
            //
            if (max >= i) {
                curLong = nums[i] + i;
                max = Math.max(max, curLong);
            }
            else {
                return false;
            }
        }
        return true;
    }
}
```

### 45. 跳跃游戏II

```java
class Solution {
    public int jump(int[] nums) {
        int len = nums.length;
        if (len == 1) { return 0; }
        int max = nums[0];
        int curMax = nums[0];
        int count = 1;
        if (max >= len) { return 1; }
        
        int i = 0;
        while (max < len - 1) {
            for (int j = i; j <= max; j++) {
                if (nums[j] + j > curMax) {
                    curMax = nums[j] + j;
                    i = j;
                }
            }
            max = curMax;
            count++;
        }
        return count;
    }
}
```

* 官方

```java
class Solution {
    public int jump(int[] nums) {
        int length = nums.length;
        int end = 0;
        int maxPosition = 0; 
        int steps = 0;
        for (int i = 0; i < length - 1; i++) {
            maxPosition = Math.max(maxPosition, i + nums[i]); 
            if (i == end) {
                end = maxPosition;
                steps++;
            }
        }
        return steps;
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/jump-game-ii/solution/tiao-yue-you-xi-ii-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

### 134. 加油站

```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int len = gas.length;
        int[] tank = new int[len];

        tank[0] = gas[0] - cost[0];
        int minIndex = 0;
        int minTank = tank[0];

        if (len == 1) {
            if (tank[0] < 0) { return -1; }
            else { return 0; }
        }
        
        for (int i = 1; i < len; i++) {
            tank[i] = tank[i - 1] + gas[i] - cost[i];
            if (minTank >= tank[i]) {
                minTank = tank[i];
                minIndex = i;
            }
        }

        //minTank >= tank[i]: 有相同的最小值 则取靠后的 （因为答案唯一 所以靠前的minTank=0 无法继续向前行驶）
        //得到的 minIndex 即为 唯一可能 的终点

        //两种情况：1. 终点若为最后一个加油站
        if (minIndex == len - 1) {
            for (int i = 1; i < len - 1; i++) {
                if (tank[i] <= 0) {
                    return -1;
                }
            }
            if (tank[len - 1] < 0) {
                return -1;
            }
            else {
                return 0;
            }
        }
        //2. 如果终点在除了最后一个加油站以外的其他加油站
        else {
            if (tank[len - 1] < 0) {
                return -1;
            }
            for (int i = 0; i < len - 1; i++) {
                if (i != minIndex && i != minIndex + 1 && tank[i] == minTank) {
                    return - 1;
                }
            }
            return minIndex + 1;
        }
    }
}
```

### 135. 分发糖果

```java
class Solution {
    int[] cans;
    int len;
    public int candy(int[] ratings) {
        len = ratings.length;
        cans = new int[len];
        Arrays.fill(cans, 0);
        for (int i = 0; i < len; i++) {
            setCandy(ratings, i);
        }
        int sum = 0;
        for (int v : cans) {
            sum += v;
        }
        return sum;
    }

    public void setCandy(int[] ratings, int index) {
        //该孩子已设置过糖果数 则跳过
        if (cans[index] != 0) { return; }
        int ans = 1;
        
        //比较与左右的评分高低，若比左右高 则先设置左右孩子糖果数
        //与左边比较
        if (index > 0) {
            if (ratings[index] > ratings[index - 1]) {
                setCandy(ratings, index - 1);
                ans = Math.max(cans[index - 1] + 1, ans);
            }
        }
        //与右边比较
        if (index < len - 1) {
            if (ratings[index] > ratings[index + 1]) {
                setCandy(ratings, index + 1);
                ans = Math.max(cans[index + 1] + 1, ans);
            }
        }
        cans[index] = ans;
    }
}
```

### 860. 柠檬水找零

```java
class Solution {
    public boolean lemonadeChange(int[] bills) {
        int m5 = 0;
        int m10 = 0;
        int m20 = 0;
        
        for (int v : bills) {
            // 5
            if (v == 5) {
                m5++;
            }
            // 10
            else if (v == 10) {
                //先给10找零
                if (m5 < 1) {
                    return false;
                }
                else {
                    m5--;
                    m10++;
                }
            }
            // 20
            else {
                //给20找零 (给20找零 5元充足的话可以没有10元 但不能没有5元)
                // 有10元
                if (m10 >= 1) {
                    if (m5 >= 1) {
                        m10--;
                        m5--;
                    }
                    else { return false; }
                }
                //没10元
                else {
                    if (m5 >= 3) {
                        m5 -= 3;
                    }
                    else { return false; }
                }
            }
        }
        return true;
    }
}
```

### 435. 无重叠区间

```java
class Solution {
    //表示该区间是否还未删除
    boolean[] isExist;
    int len;
    //当前删除区间数
    int delCount;
    //最少删除区间数 为该题的返回值
    int minDel;

    boolean[][] lapTable;

    public int eraseOverlapIntervals(int[][] intervals) {
        len = intervals.length;
        isExist = new boolean[len];
        Arrays.fill(isExist, true);
        delCount = 0;
        minDel = len;
        //存储每个区间相互是否重叠
        lapTable = new boolean[len][len];
        for (int i = 0; i < len; i++) {
            for (int j = i; j < len; j++) {
                boolean isLap = isOverlap(intervals, i, j);
                lapTable[i][j] = isLap;
                lapTable[j][i] = isLap;
            }
        }

        dfs(intervals, 0);
        return minDel;
    }

    public void dfs(int[][] intervals, int start) {
        //剪枝
        if (minDel <= delCount + 1) { return; }
        //终止
        if (start == len) {
            boolean hasOverlap = false;
            for (int i = 0; i < len; i++) {
                if (!isExist[i]) { continue; }
                for (int j = i + 1; j < len; j++) {
                    if (j == i || !isExist[j]) { continue; }
                    if (lapTable[i][j]) {
                        hasOverlap = true;
                        break;
                    }
                }
                if (hasOverlap) { break; }
            }

            //回溯终止条件
            if (!hasOverlap) {
                minDel = Math.min(minDel, delCount);
                // System.out.println(Arrays.toString(isExist));
            }
            return;
        }

        //剪枝
        //找出从start索引开始 第一个与其他区间有重叠的索引
        int nextIndex = start;
        boolean isFoundNext = false;
        for (int i = start; i < len; i++) {
            if (!isExist[i]) { continue; }
            for (int j = 0; j < len; j++) {
                if (j == i || !isExist[j]) { continue; }
                if (lapTable[i][j]) {
                    isFoundNext = true;
                    nextIndex = i;
                    break;
                }
            }
            if (isFoundNext) { break; }
        }

        //backtrace body
        if (isFoundNext) {
            isExist[nextIndex] = false;
            delCount++;
            dfs(intervals, nextIndex + 1);
            isExist[nextIndex] = true;
            delCount--;
            dfs(intervals, nextIndex + 1);
        }
    }

    //计算两个区间是否重叠
    public boolean isOverlap(int[][] intervals, int a, int b) {
        if (intervals[a][0] <= intervals[b][0] && intervals[a][1] <= intervals[b][0]) {
            return false;
        }
        if (intervals[a][0] >= intervals[b][1] && intervals[a][1] >= intervals[b][1]) {
            return false;
        }
        return true;
    }
}
```

Compare 排序 Comparator

```java
Arrays.sort(intervals, new Comparator<int[]>() {
    public int compare(int[] intervals1, int[] intervals2) {
        return intervals1[0] - intervals2[0];
    }
});
```

### 763. 划分字母区间

```java
class Solution {
    public List<Integer> partitionLabels(String s) {
        List<Integer> ans = new LinkedList();
        int len = s.length();
        //遍历一遍 s ，将所有字符存入 HashMap， value表示出现次数
        HashMap<Character, Integer> remain = new HashMap();
        for (int i = 0; i < len; i++) {
            remain.put(s.charAt(i), remain.getOrDefault(s.charAt(i), 0) + 1);
        }

        for (int start = 0; start < len; start++) {
            HashSet<Character> curSet = new HashSet();
            int count = 0;
            for (int i = start; i < len; i++) {
                char tmp = s.charAt(i);
                curSet.add(tmp);
                remain.put(tmp, remain.getOrDefault(tmp, 0) - 1);
                count++;
                if (isLastOne(curSet, remain)) {
                    ans.add(count);
                    start = i;
                    break;
                }
            }
        }
        return ans;
    }
    
    //判断剩余集合 remain 中是否还含有当前字母
    public boolean isLastOne(HashSet<Character> curSet, HashMap<Character, Integer> remain) {
        for (Character v : curSet) {
            if (remain.get(v) > 0) {
                return false;
            }
        }
        return true;
    }
}
```

### 56. 合并区间

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        int len = intervals.length;
        Arrays.sort(intervals, new Comparator<int[]>() {
            public int compare(int[] inter1, int[] inter2) {
                return inter1[0] - inter2[0];
            }
        });
        //初始化
        int[][] ans = new int[len][2];
        int ansIndex = 0;
        int left = intervals[0][0];
        int right = intervals[0][1];
        ans[ansIndex][0] = left;
        ans[ansIndex][1] = right;

        //
        for (int i = 1; i < len; i++) {
            //与上一个ans区间无重叠
            if (intervals[i][0] > right) {
                ansIndex++;
                ans[ansIndex][0] = intervals[i][0];
                ans[ansIndex][1] = intervals[i][1];
                left = intervals[i][0];
                right = intervals[i][1];
            }
            //有重叠
            else {
                right = Math.max(right, intervals[i][1]);
                ans[ansIndex][1] = right;
            }
        }
        return Arrays.copyOfRange(ans, 0, ansIndex + 1);
    }
}
```

&nbsp;

---

&nbsp;

## 📡动 态 规 划

* **【TODO】**

&nbsp;

---

&nbsp;

## 🧩图 论

* **【TODO】**

&nbsp;

---

&nbsp;

## 🎯高 级 数 据 结 构

* **【TODO】**
