# 📝My LeetCode Note

## 🗺️路线

* [🔢数组](#数-组) --> [⛓️链表](#%EF%B8%8F链-表) --> [🧾哈希表](#哈-希-表) --> [🔡字符串](#字-符-串) --> [🈯️双指针法](#%EF%B8%8F双-指-针-法)  --> [🎢栈与队列](#栈-与-队-列) --> [🌳树](#树) --> [🔙回溯](#回-溯) --> [💯贪心](#贪-心) --> [📡动态规划](#动-态-规-划) --> [🧩图论](#图-论) --> [🎯高级数据结构](#高-级-数-据-结-构)

按题型刷完后，再从`简单`刷起，做了几个类型题目之后，再慢慢做`中等`题目、`困难`题目。

* 路线 from：[代码随想录](https://programmercarl.com/)

* 题解语言：`Java`

&nbsp;

---
&nbsp;

## 🔢数 组

### 27. 移除元素

* **【TODO】**

### 26. 删除排序数组中的重复项

* **【TODO】**

### 283. 移动零

* **【TODO】**

### [844. 比较含退格的字符串](./Solutions/844.比较含退格的字符串.md)

### [977. 有序数组的平方](./Solutions/977.有序数组的平方.md)

### [209. 长度最小的子数组](./Solutions/209.长度最小的子数组.md)

### [904. 水果成篮](./Solutions/904.水果成篮.md)

### [76. 最小覆盖子串](./Solutions/76.最小覆盖子串.md)

### [59. 螺旋矩阵 II](./Solutions/59.螺旋矩阵II.md)

&nbsp;

---

&nbsp;

## ⛓️链 表

### [203. 移除链表元素](./Solutions/203.移除链表元素.md)

### [707. 设计链表](./Solutions/707.设计链表.md)

### [206. 反转链表](./Solutions/206.反转链表.md)

### [24. 两两交换链表中的节点](./Solutions/24.两两交换链表中的节点.md)

### [19. 删除链表的倒数第 N 个结点](./Solutions/19.删除链表的倒数第N个结点.md)

### [面试题 02.07. 链表相交](./Solutions/面试题02.07.链表相交.md)

### [142. 环形链表II](./Solutions/142.环形链表II.md)

&nbsp;

---

&nbsp;

## 🧾哈 希 表

### 基础：

**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法**。

但是哈希法也是**牺牲了空间换取了时间**，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。

如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！

[( from 代码随想录 哈希表理论基础 )](https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%89%E7%A7%8D%E5%93%88%E5%B8%8C%E7%BB%93%E6%9E%84)

&nbsp;

### [242. 有效的字母异位词](./Solutions/242.有效的字母异位词.md)

### [383. 赎金信](./Solutions/383.赎金信.md)

### [49. 字母异位词分组](./Solutions/49.字母异位词分组.md)

### [438. 找到字符串中所有字母异位词](./Solutions/438.找到字符串中所有字母异位词.md)

### [349. 两个数组的交集](./Solutions/350.两个数组的交集II.md)

### [202. 快乐数](./Solutions/202.快乐数.md)

### 1. 两数之和

* **【TODO】**

### [454. 四数相加II](./Solutions/454.四数相加II.md)

### [15. 三数之和](./Solutions/15.三数之和.md)

### 18. 四数之和

* **【TODO】**

&nbsp;

---

&nbsp;

## 🔡字 符 串

### 344. 反转字符串

* **【TODO】**

### [541. 反转字符串II](./Solutions/541.反转字符串II.md)

### [剑指Offer 05. 替换空格](./Solutions/剑指Offer05.替换空格.md)

### [151. 翻转字符串里的单词](./Solutions/151.翻转字符串里的单词.md)

### [剑指Offer58-II. 左旋转字符串](./Solutions/剑指Offer58-II.左旋转字符串.md)

### [28. 实现 strStr()](./Solutions/28.实现strStr().md)

### [459. 重复的子字符串](./Solutions/459.重复的子字符串.md)

&nbsp;

---

&nbsp;

## 🈯️双 指 针 法

### [27. 移除元素](./Solutions/27.移除元素.md)

### [344. 反转字符串](./Solutions/344.反转字符串.md)

### 151.翻转字符串里的单词

### 206.反转链表

### 19.删除链表的倒数第N个节点

### 面试题 02.07. 链表相交

### 142.环形链表II

### 15. 三数之和

### 18. 四数之和

&nbsp;

---

&nbsp;


## 🎢栈 与 队 列

### [232. 用栈实现队列](./Solutions/232.用栈实现队列.md)

### [225. 用队列实现栈](./Solutions/225.用队列实现栈.md)

### [20. 有效的括号](./Solutions/20.有效的括号.md)

### [1047. 删除字符串中的所有相邻重复项](./Solutions/1047.删除字符串中的所有相邻重复项.md)

### [150. 逆波兰表达式求值](./Solutions/150.逆波兰表达式求值.md)

### [239. 滑动窗口最大值](./Solutions/239.滑动窗口最大值.md)

### [347. 前K个高频元素](./Solutions/347.前K个高频元素.md)

### 栈与队列总结



* **【TODO】**

&nbsp;

---

&nbsp;

## 🌳树

### [144. 二叉树的前序遍历](./Solutions/144.二叉树的前序遍历.md)

### [145. 二叉树的后序遍历](./Solutions/145.二叉树的后序遍历.md)

### [94. 二叉树的中序遍历](./Solutions/94.二叉树的中序遍历.md)

### [102. 二叉树的层序遍历](./Solutions/102.二叉树的层序遍历.md)

### [226. 翻转二叉树](./Solutions/226.翻转二叉树.md)

### [101. 对称二叉树](./Solutions/101.对称二叉树.md)

### [104. 二叉树的最大深度](./Solutions/104.二叉树的最大深度.md)

### 559. n叉树的最大深度

### 111. 二叉树的最小深度

### 222. 完全二叉树的节点个数

### 110. 平衡二叉树

### 257. 二叉树的所有路径

### 404. 左叶子之和

### 513. 找树左下角的值

### 112. 路径总和

### 106. 从中序与后序遍历序列构造二叉树

### 654. 最大二叉树

```java
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        int indexOfMax = ;
        int max = nums[indexOfMax];
        TreeNode cur = new TreeNode(max);
        buildTree(cur, nums);
        buildTree(cur, nums);
    }

    public void buildTree(TreeNode cur, int[] nums) {

    }
}
```

### 617. 合并二叉树

### 700. 二叉搜索树中的搜索

```java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        if (root == null) return null;
        Queue<TreeNode> que = new LinkedList();
        que.add(root);
        while (!que.isEmpty()) {
            TreeNode cur = que.remove();
            if (cur.val == val) return cur;
            if (cur.left != null) que.add(cur.left);
            if (cur.right != null) que.add(cur.right);
        }
        return null;
    }
}
```

### 98. 验证二叉搜索树

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        if (root == null) return true;
        LinkedList<Integer> log = new LinkedList();
        midTra(root, log);
        if (log.size() < 1) return true;
        for (int i = 1; i < log.size(); i++) {
            if (log.get(i) <= log.get(i - 1)) return false;
        }
        return true;
    }

    public void midTra(TreeNode root, LinkedList log) {
        if (root == null) return ;
        midTra(root.left, log);
        log.add(root.val);
        midTra(root.right, log);
    }
}
```

### 530. 二叉搜索树的最小绝对差

```java
class Solution {
    LinkedList<Integer> log = new LinkedList();
    public int getMinimumDifference(TreeNode root) {
        long min = Long.MAX_VALUE;
        inorder(root);
        for (int i = 1; i < log.size(); i++) {
            long value = log.get(i) - log.get(i - 1);
            if (value < 0) value = -value;
            if (value < min) min = value;
        }
        return (int)min;
    }

    public void inorder(TreeNode root) {
        if (root == null) return;
        inorder(root.left);
        log.add(root.val);
        inorder(root.right);
    }
}
```

### 501. 二叉搜索树中的众数

```java
class Solution {
    TreeNode pre = null;
    HashMap<Integer, Integer> freq = new HashMap();
    public int[] findMode(TreeNode root) {
        inorder(root);
        int max = 0;
        for (int k : freq.keySet()) {
            int fre = freq.get(k);
            if (fre > max) {
                max = fre;
            }
        }
        int[] ans = new int[freq.size()];
        int index = 0;
        for (int k : freq.keySet()) {
            int fre = freq.get(k);
            if (fre == max) {
                ans[index++] = k;
            }
        }
        return Arrays.copyOfRange(ans, 0, index);
    }

    public void inorder(TreeNode root) {
        if (root == null) return;
        inorder(root.left);
        freq.put(root.val, freq.getOrDefault(root.val, 0) + 1);
        inorder(root.right);
    }
}
```

### 236. 二叉树的最近公共祖先

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    TreeNode pub;
    boolean foundFirst = false;
    boolean isDone = false;
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        order(root, p, q);
        return pub;
    }

    public void order(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null) return;

        //中序搜索 左子节点递归
        if (!isDone) order(root.left, p, q);

        if (!isDone) {
            //未搜索到第一个节点 中序遍历
            if (!foundFirst) {
                //搜索第一个节点
                if (root.val == p.val || root.val == q.val) {
                    foundFirst = true;
                    pub = root;
                    if (root.left == null && root.right == null) {
                    //是叶子结点 直接结束递归

                    return;
                    }
                }
            }
            //已找到第一个节点
            else {
                if (isFather(pub, root)) {
                    pub = root;
                }
                if (root.val == p.val || root.val == q.val) {
                    //已经搜索到第二个节点 标记flag isDone 结束之后的所有递归
                    isDone = true;
                    return;
                }
            }
        }
        //右子节点中序遍历递归
        if (!isDone) order(root.right, p, q);
    }

    //判断 son 是否在 father 的子树中
    public boolean isFather(TreeNode son, TreeNode father) {
        if (father == null || son == null) { return false; }
        if (father.left != null && father.left.val == son.val) { return true; }
        if (father.right != null && father.right.val == son.val) { return true; }
        return isFather(son, father.left) || isFather(son, father.right);
    }
}
```
* Solution 2

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */

class Solution {
    TreeNode ans = null;
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        tra(root, p, q);
        return ans;
    }

    public boolean tra(TreeNode cur, TreeNode p, TreeNode q) {
        if (cur == null) return false;
        boolean lhave = tra(cur.left, p, q);
        boolean rhave = tra(cur.right, p, q);
        //左右各一个节点 则该节点为目标节点
        if (lhave && rhave) { ans = cur; }
        //当前节点为一个，子树含一个，则该节点为目标节点
        if ((cur == p) || (cur == q) && (lhave || rhave)) { ans = cur; }
        return lhave || rhave || (cur == p) || (cur == q);
    }
}
```

### 235. 二叉搜索树的最近公共祖先

```java

```

### 701.二叉搜索树中的插入操作

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if (root == null) { return new TreeNode(val); }
        TreeNode tar = new TreeNode(val);
        locate(root, tar);
        return root;
    }

    public void locate(TreeNode root, TreeNode tar) {
        TreeNode cur = root;
        if (tar.val < cur.val) {
            if (cur.left != null) {
                locate(cur.left, tar);
            }
            else {
                cur.left = tar;
            }
        }
        else if (tar.val > cur.val) {
            if (cur.right != null) {
                locate(cur.right, tar);
            }
            else {
                cur.right = tar;
            }
        }
    }
}
```

### 450.删除二叉搜索树中的节点

```java
此题和669 重点在每次递归的返回值 是该节点本身（涉及删除该节点 则若需要删除 就返回删除后的替代节点）

```java
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        if (root == null) return null;

        if (root.val == key) {
            // 情况1、2：被删除节点没有子节点、没有左子树、没有右子树
            if (root.left == null) return root.right;
            if (root.right == null) return root.left;
            // 情况3：被删除节点既有左子树，又有右子树：取右子树的最小节点取代被删除节点，并删除右子树的最小节点
            TreeNode minNodeOfRight = findMinNode(root.right);
            root.val = minNodeOfRight.val;
            root.right = deleteNode(root.right, minNodeOfRight.val);
        } else if (root.val < key) {
            root.right = deleteNode(root.right, key);
        } else if (root.val > key) {
            root.left = deleteNode(root.left, key);
        }

        return root;
    }

    private TreeNode findMinNode(TreeNode node) {
        while (node.left != null) {
            node = node.left;
        }
        return node;
    }
}

作者：ar-lai
链接：https://leetcode-cn.com/problems/delete-node-in-a-bst/solution/javachao-jian-dan-de-er-fen-sou-suo-di-g-z83v/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

* 仿写

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode deleteNode(TreeNode cur, int key) {
        if (cur == null) return null;

        if (cur.val == key) {
            //cur 只有单子节点或无子节点
            if (cur.left == null) return cur.right;
            if (cur.right == null) return cur.left;

            //含有两个子节点
            TreeNode maxOfLeft = cur.left;
            while (maxOfLeft.right != null) {
                maxOfLeft = maxOfLeft.right;
            }
            cur.val = maxOfLeft.val;
            cur.left = deleteNode(cur.left, maxOfLeft.val);
        }
        else if (cur.val < key) {
            cur.right = deleteNode(cur.right, key);
        }
        else if (cur.val > key) {
            cur.left = deleteNode(cur.left, key);
        }
        return cur;
    }
}
```

### 669. 修剪二叉搜索树

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode trimBST(TreeNode root, int low, int high) {
        if (root == null) return null;
        int value = root.val;
        if (value < low) {
            root = trimBST(root.right, low, high);
        }
        else if (value > high) {
            root = trimBST(root.left, low, high);
        }
        else {
            root.left = trimBST(root.left, low, high);
            root.right = trimBST(root.right, low, high);
        }
        return root;
    }
}
```

### 108.将有序数组转换为二叉搜索树

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        TreeNode start = new TreeNode();
        make(nums, start, 0, nums.length - 1);
        return start;
    }

    public void make(int[] nums, TreeNode cur, int low, int high) {
        int mid = (high + low) / 2;
        if (low > high) { return; }

        cur.val = nums[mid];
        if (low == high) { return; }

        if (high - low == 1) {
            cur.right = new TreeNode(); 
            make(nums, cur.right, high, high);
            return;
        }
		//high - low > 1:
        cur.left = new TreeNode(); 
        cur.right = new TreeNode(); 

        make(nums, cur.left, low, mid - 1);
        make(nums, cur.right, mid + 1, high);
    }
}
```

### 538.把二叉搜索树转换为累加树

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int sum = 0;
    // right - root - left
    public TreeNode convertBST(TreeNode root) {
        if (root == null) return null;
        //right
        convertBST(root.right);
        //root
        sum += root.val;
        root.val = sum;

        //left
        convertBST(root.left);
        return root;
    }
}
```

&nbsp;

---

&nbsp;

## 🔙回 溯

&nbsp;

### 77. 组合

```java
class Solution {
    LinkedList<Integer> base = new LinkedList();
    List<List<Integer>> ans = new ArrayList();
    public List<List<Integer>> combine(int n, int k) {
        comb(n, k, 1);
        return ans;
    }

    public void comb(int n, int k, int start) {
        if (base.size() == k) {
            ans.add(new ArrayList(base));
            return;
        }

        for (int i = start; i <= n; i++) {
            base.add(i);
            comb(n, k, i + 1);
            base.removeLast();
        }
    }
}
```

&nbsp;

---

&nbsp;

## 💯贪 心

* **【TODO】**

&nbsp;

---

&nbsp;

## 📡动 态 规 划

* **【TODO】**

&nbsp;

---

&nbsp;

## 🧩图 论

* **【TODO】**

&nbsp;

---

&nbsp;

## 🎯高 级 数 据 结 构

* **【TODO】**
