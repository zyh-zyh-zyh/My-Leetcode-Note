# 📝My LeetCode Note

## 🗺️路线

* [🔢数组](#数-组) --> [⛓️链表](#%EF%B8%8F链-表) --> [🧾哈希表](#哈-希-表) --> [🔡字符串](#字-符-串) --> [🈯️双指针法](#%EF%B8%8F双-指-针-法)  --> [🎢栈与队列](#栈-与-队-列) --> [🌳树](#树) --> [🔙回溯](#回-溯) --> [💯贪心](#贪-心) --> [📡动态规划](#动-态-规-划) --> [🧩图论](#图-论) --> [🎯高级数据结构](#高-级-数-据-结-构)

按题型刷完后，再从`简单`刷起，做了几个类型题目之后，再慢慢做`中等`题目、`困难`题目。

* 路线 from：[代码随想录](https://programmercarl.com/)

* 题解语言：`Java`

&nbsp;

---
&nbsp;

## 🔢数 组

### 27. 移除元素

* **【TODO】**

### 26. 删除排序数组中的重复项

* **【TODO】**

### 283. 移动零

* **【TODO】**

### [844. 比较含退格的字符串](./Solutions/844.比较含退格的字符串.md)

### [977. 有序数组的平方](./Solutions/977.有序数组的平方.md)

### [209. 长度最小的子数组](./Solutions/209.长度最小的子数组.md)

### [904. 水果成篮](./Solutions/904.水果成篮.md)

### [76. 最小覆盖子串](./Solutions/76.最小覆盖子串.md)

### [59. 螺旋矩阵 II](./Solutions/59.螺旋矩阵II.md)

&nbsp;

---

&nbsp;

## ⛓️链 表

### [203. 移除链表元素](./Solutions/203.移除链表元素.md)

### [707. 设计链表](./Solutions/707.设计链表.md)

### [206. 反转链表](./Solutions/206.反转链表.md)

### [24. 两两交换链表中的节点](./Solutions/24.两两交换链表中的节点.md)

### [19. 删除链表的倒数第 N 个结点](./Solutions/19.删除链表的倒数第N个结点.md)

### [面试题 02.07. 链表相交](./Solutions/面试题02.07.链表相交.md)

### [142. 环形链表II](./Solutions/142.环形链表II.md)

&nbsp;

---

&nbsp;

## 🧾哈 希 表

### 基础：

**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法**。

但是哈希法也是**牺牲了空间换取了时间**，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。

如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！

[( from 代码随想录 哈希表理论基础 )](https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%89%E7%A7%8D%E5%93%88%E5%B8%8C%E7%BB%93%E6%9E%84)

&nbsp;

### [242. 有效的字母异位词](./Solutions/242.有效的字母异位词.md)

### [383. 赎金信](./Solutions/383.赎金信.md)

### [49. 字母异位词分组](./Solutions/49.字母异位词分组.md)

### [438. 找到字符串中所有字母异位词](./Solutions/438.找到字符串中所有字母异位词.md)

### [349. 两个数组的交集](./Solutions/350.两个数组的交集II.md)

### [202. 快乐数](./Solutions/202.快乐数.md)

### 1. 两数之和

* **【TODO】**

### [454. 四数相加II](./Solutions/454.四数相加II.md)

### [15. 三数之和](./Solutions/15.三数之和.md)

### 18. 四数之和

* **【TODO】**

&nbsp;

---

&nbsp;

## 🔡字 符 串

### 344. 反转字符串

* **【TODO】**

### [541. 反转字符串II](./Solutions/541.反转字符串II.md)

### [剑指Offer 05. 替换空格](./Solutions/剑指Offer05.替换空格.md)

### [151. 翻转字符串里的单词](./Solutions/151.翻转字符串里的单词.md)

### [剑指Offer58-II. 左旋转字符串](./Solutions/剑指Offer58-II.左旋转字符串.md)

### [28. 实现 strStr()](./Solutions/28.实现strStr().md)

### [459. 重复的子字符串](./Solutions/459.重复的子字符串.md)

&nbsp;

---

&nbsp;

## 🈯️双 指 针 法

### [27. 移除元素](./Solutions/27.移除元素.md)

### [344. 反转字符串](./Solutions/344.反转字符串.md)

### 151.翻转字符串里的单词

### 206.反转链表

### 19.删除链表的倒数第N个节点

### 面试题 02.07. 链表相交

### 142.环形链表II

### 15. 三数之和

### 18. 四数之和

&nbsp;

---

&nbsp;


## 🎢栈 与 队 列

### [232. 用栈实现队列](./Solutions/232.用栈实现队列.md)

### [225. 用队列实现栈](./Solutions/225.用队列实现栈.md)

### [20. 有效的括号](./Solutions/20.有效的括号.md)

### [1047. 删除字符串中的所有相邻重复项](./Solutions/1047.删除字符串中的所有相邻重复项.md)

### [150. 逆波兰表达式求值](./Solutions/150.逆波兰表达式求值.md)

### [239. 滑动窗口最大值](./Solutions/239.滑动窗口最大值.md)

### [347. 前K个高频元素](./Solutions/347.前K个高频元素.md)

### 栈与队列总结



* **【TODO】**

&nbsp;

---

&nbsp;

## 🌳树

### [144. 二叉树的前序遍历](./Solutions/144.二叉树的前序遍历.md)

### [145. 二叉树的后序遍历](./Solutions/145.二叉树的后序遍历.md)

### [94. 二叉树的中序遍历](./Solutions/94.二叉树的中序遍历.md)

### [102. 二叉树的层序遍历](./Solutions/102.二叉树的层序遍历.md)

### [226. 翻转二叉树](./Solutions/226.翻转二叉树.md)

### [101. 对称二叉树](./Solutions/101.对称二叉树.md)

### [104. 二叉树的最大深度](./Solutions/104.二叉树的最大深度.md)

### 559. n叉树的最大深度

### [111. 二叉树的最小深度](./Solutions/111.二叉树的最小深度.md)

### [222. 完全二叉树的节点个数](./Solutions/222.完全二叉树的节点个数.md)

### [110. 平衡二叉树](./Solutions/110.平衡二叉树.md)

### [257. 二叉树的所有路径](./Solutions/257.二叉树的所有路径.md)

### [404. 左叶子之和](./Solutions/404.左叶子之和.md)

### [513. 找树左下角的值](./Solutions/513.找树左下角的值.md)

### [112. 路径总和](./Solutions/112.路径总和.md)

### 106. 从中序与后序遍历序列构造二叉树

### [654. 最大二叉树](./Solutions/654.最大二叉树.md)

### [617. 合并二叉树](./Solutions/617.合并二叉树.md)

### 700. 二叉搜索树中的搜索

### 98. 验证二叉搜索树

### 530. 二叉搜索树的最小绝对差

### 501. 二叉搜索树中的众数

### 236. 二叉树的最近公共祖先

### 235. 二叉搜索树的最近公共祖先

```java

```

### 701. 二叉搜索树中的插入操作

### 450. 删除二叉搜索树中的节点

### 669. 修剪二叉搜索树

### 108.将有序数组转换为二叉搜索树

### 538.把二叉搜索树转换为累加树

&nbsp;

---

&nbsp;

## 🔙回 溯

&nbsp;

### 77. 组合

### 216. 组合总和 III

### 17. 电话号码的字母组合

### 39. 组合总和

### 40. 组合总和II

### 131. 分割回文串

### 93. 复原IP地址

### 78. 子集问题

### 90. 子集II

### 491. 递增子序列

### 46. 全排列

### 47. 全排列II

### 332. 重新安排行程

```java

```

### 51. N皇后

```java

```

### 37. 解数独

```java

```

&nbsp;

---

&nbsp;

## 💯贪 心

&nbsp;

### 455. 分发饼干

### 376. 摆动序列

### 53. 最大子序和

### 122. 买卖股票的最佳时机II

### 55. 跳跃游戏

### 45. 跳跃游戏II

### 134. 加油站

### 135. 分发糖果

### 860. 柠檬水找零

### 435. 无重叠区间

### 763. 划分字母区间

```java
class Solution {
    public List<Integer> partitionLabels(String s) {
        List<Integer> ans = new LinkedList();
        int len = s.length();
        //遍历一遍 s ，将所有字符存入 HashMap， value表示出现次数
        HashMap<Character, Integer> remain = new HashMap();
        for (int i = 0; i < len; i++) {
            remain.put(s.charAt(i), remain.getOrDefault(s.charAt(i), 0) + 1);
        }

        for (int start = 0; start < len; start++) {
            HashSet<Character> curSet = new HashSet();
            int count = 0;
            for (int i = start; i < len; i++) {
                char tmp = s.charAt(i);
                curSet.add(tmp);
                remain.put(tmp, remain.getOrDefault(tmp, 0) - 1);
                count++;
                if (isLastOne(curSet, remain)) {
                    ans.add(count);
                    start = i;
                    break;
                }
            }
        }
        return ans;
    }
    
    //判断剩余集合 remain 中是否还含有当前字母
    public boolean isLastOne(HashSet<Character> curSet, HashMap<Character, Integer> remain) {
        for (Character v : curSet) {
            if (remain.get(v) > 0) {
                return false;
            }
        }
        return true;
    }
}
```

### 56. 合并区间

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        int len = intervals.length;
        Arrays.sort(intervals, new Comparator<int[]>() {
            public int compare(int[] inter1, int[] inter2) {
                return inter1[0] - inter2[0];
            }
        });
        //初始化
        int[][] ans = new int[len][2];
        int ansIndex = 0;
        int left = intervals[0][0];
        int right = intervals[0][1];
        ans[ansIndex][0] = left;
        ans[ansIndex][1] = right;

        //
        for (int i = 1; i < len; i++) {
            //与上一个ans区间无重叠
            if (intervals[i][0] > right) {
                ansIndex++;
                ans[ansIndex][0] = intervals[i][0];
                ans[ansIndex][1] = intervals[i][1];
                left = intervals[i][0];
                right = intervals[i][1];
            }
            //有重叠
            else {
                right = Math.max(right, intervals[i][1]);
                ans[ansIndex][1] = right;
            }
        }
        return Arrays.copyOfRange(ans, 0, ansIndex + 1);
    }
}
```

&nbsp;

---

&nbsp;

## 📡动 态 规 划

* **【TODO】**

&nbsp;

---

&nbsp;

## 🧩图 论

* **【TODO】**

&nbsp;

---

&nbsp;

## 🎯高 级 数 据 结 构

* **【TODO】**
&nbsp;

---

&nbsp;
## 📌增补题目

### 91. 解码方法
MySolution
```java
class Solution {
    public int numDecodings(String s) {
        int len = s.length();
        int[] dp = new int[len + 1];
        dp[0] = 1;
        for (int i = 1; i < len + 1; i++) {
            if (i > 1 && dp[i - 1] == 0) {
                dp[i] = 0;
                continue;
            }
            char cur = s.charAt(i - 1);
            //第一位字母
            if (i == 1) {
                if (cur != '0') {
                    dp[i] = 1;
                }
            }
            //非第一位字母
            else {
                char pre = s.charAt(i - 2);
                //0
                if (cur == '0') {
                    if (pre == '1' || pre == '2') {
                        dp[i] = dp[i - 2];
                    }
                    else {
                        dp[i] = 0;
                    }
                }
                // 1-6
                else if (cur - '0' > 0 && cur - '0' < 7) {
                    if (pre == '1' || pre == '2') {
                        dp[i] = dp[i - 2] + dp[i - 1];
                    }
                    else {
                        dp[i] = dp[i - 1];
                    }
                }
                //7 8 9
                else {
                    if (pre == '1') {
                        dp[i] = dp[i - 2] + dp[i - 1];
                    }
                    else {
                        dp[i] = dp[i - 1];
                    }
                }
            }
        }
        return dp[len];
    }
}

```

Leetcode solution
```java
class Solution {
    public int numDecodings(String s) {
        int n = s.length();
        int[] f = new int[n + 10];
        f[0] = 1;
        for(int i = 1; i <= n;i ++)
        {
            if(s.charAt(i - 1) != '0') f[i] = f[i - 1]; //单独解码s[i - 1]
            if(i >= 2)
            {
                int t = (s.charAt(i - 2) - '0') * 10 + s.charAt(i - 1) - '0';
                if(t >= 10 && t <= 26) f[i] += f[i - 2]; //将s[i - 2] 和 s[i - 1]组合解码
            }
        }
        return f[n];
    }
}

作者：lin-shen-shi-jian-lu-k
链接：https://leetcode-cn.com/problems/decode-ways/solution/jie-ma-fang-fa-tu-jie-dp-zui-qing-xi-yi-97hng/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```