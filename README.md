# 📝My LeetCode Note

## 🗺️路线

* [🔢数组](#数-组) --> [⛓️链表](#%EF%B8%8F链-表) --> [🧾哈希表](#哈-希-表) --> [🔡字符串](#字-符-串) --> [🈯️双指针法](#%EF%B8%8F双-指-针-法)  --> [🎢栈与队列](#栈-与-队-列) --> [🌳树](#树) --> [🔙回溯](#回-溯) --> [💯贪心](#贪-心) --> [📡动态规划](#动-态-规-划) --> [🧩图论](#图-论) --> [🎯高级数据结构](#高-级-数-据-结-构)

按题型刷完后，再从`简单`刷起，做了几个类型题目之后，再慢慢做`中等`题目、`困难`题目。

* 路线 from：[代码随想录](https://programmercarl.com/)

* 题解语言：`Java`

&nbsp;

---
&nbsp;

## 🔢数 组

### 27. 移除元素

* **【TODO】**

### 26. 删除排序数组中的重复项

* **【TODO】**

### 283. 移动零

* **【TODO】**

### [844. 比较含退格的字符串](./Solutions/844.比较含退格的字符串.md)

### [977. 有序数组的平方](./Solutions/977.有序数组的平方.md)

### [209. 长度最小的子数组](./Solutions/209.长度最小的子数组.md)

### [904. 水果成篮](./Solutions/904.水果成篮.md)

### [76. 最小覆盖子串](./Solutions/76.最小覆盖子串.md)

### [59. 螺旋矩阵 II](./Solutions/59.螺旋矩阵II.md)

&nbsp;

---

&nbsp;

## ⛓️链 表

### [203. 移除链表元素](./Solutions/203.移除链表元素.md)

### [707. 设计链表](./Solutions/707.设计链表.md)

### [206. 反转链表](./Solutions/206.反转链表.md)

### [24. 两两交换链表中的节点](./Solutions/24.两两交换链表中的节点.md)

### [19. 删除链表的倒数第 N 个结点](./Solutions/19.删除链表的倒数第N个结点.md)

### [面试题 02.07. 链表相交](./Solutions/面试题02.07.链表相交.md)

### [142. 环形链表II](./Solutions/142.环形链表II.md)

&nbsp;

---

&nbsp;

## 🧾哈 希 表

### 基础

**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法**。

但是哈希法也是**牺牲了空间换取了时间**，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。

如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！

[( from 代码随想录 哈希表理论基础 )](https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%89%E7%A7%8D%E5%93%88%E5%B8%8C%E7%BB%93%E6%9E%84)

&nbsp;

### [242. 有效的字母异位词](./Solutions/242.有效的字母异位词.md)

### [383. 赎金信](./Solutions/383.赎金信.md)

### [49. 字母异位词分组](./Solutions/49.字母异位词分组.md)

### [438. 找到字符串中所有字母异位词](./Solutions/438.找到字符串中所有字母异位词.md)

### [349. 两个数组的交集](./Solutions/350.两个数组的交集II.md)

### [202. 快乐数](./Solutions/202.快乐数.md)

### 1. 两数之和

* **【TODO】**

### [454. 四数相加II](./Solutions/454.四数相加II.md)

### [15. 三数之和](./Solutions/15.三数之和.md)

### 18. 四数之和

* **【TODO】**

&nbsp;

---

&nbsp;

## 🔡字 符 串

### 344. 反转字符串

* **【TODO】**

### [541. 反转字符串II](./Solutions/541.反转字符串II.md)

### [剑指Offer 05. 替换空格](./Solutions/剑指Offer05.替换空格.md)

### [151. 翻转字符串里的单词](./Solutions/151.翻转字符串里的单词.md)

### [剑指Offer58-II. 左旋转字符串](./Solutions/剑指Offer58-II.左旋转字符串.md)

### [28. 实现 strStr()](./Solutions/28.实现strStr().md)

### [459. 重复的子字符串](./Solutions/459.重复的子字符串.md)

&nbsp;

---

&nbsp;

## 🈯️双 指 针 法

### [27. 移除元素](./Solutions/27.移除元素.md)

### [344. 反转字符串](./Solutions/344.反转字符串.md)

### 151.翻转字符串里的单词

### 206.反转链表

### 19.删除链表的倒数第N个节点

### 面试题 02.07. 链表相交

### 142.环形链表II

### 15. 三数之和

### 18. 四数之和

&nbsp;

---

&nbsp;


## 🎢栈 与 队 列

### [232. 用栈实现队列](./Solutions/232.用栈实现队列.md)

### [225. 用队列实现栈](./Solutions/225.用队列实现栈.md)

### [20. 有效的括号](./Solutions/20.有效的括号.md)

### [1047. 删除字符串中的所有相邻重复项](./Solutions/1047.删除字符串中的所有相邻重复项.md)

### [150. 逆波兰表达式求值](./Solutions/150.逆波兰表达式求值.md)

### [239. 滑动窗口最大值](./Solutions/239.滑动窗口最大值.md)

### [347. 前K个高频元素](./Solutions/347.前K个高频元素.md)

### 栈与队列总结



* **【TODO】**

&nbsp;

---

&nbsp;

## 🌳树

### [144. 二叉树的前序遍历](./Solutions/144.二叉树的前序遍历.md)

### 145. 二叉树的后序遍历

### 94.二叉树的中序遍历

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList();
        inorder(root, list);
        return list;
    }

    public void inorder(TreeNode root, List<Integer> list) {
        if (root == null) {return;}
        inorder(root.left, list);
        list.add(root.val);
        inorder(root.right, list);
    }
}
```

* 堆栈

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList();
        Stack<TreeNode> st = new Stack();
        HashSet<TreeNode> seenSet = new HashSet();

        if (root == null) {return ans;}
        st.push(root);
        while (!st.empty()) {
            //先 pop() 取出来 
            TreeNode curNode = st.pop();
            //若见过 则直接添加至 ans 
            if (seenSet.contains(curNode)) {
                ans.add(curNode.val);
                continue;
            }
            //若未见过 则按 右中左顺序推回栈中
            seenSet.add(curNode);

            if (curNode.right != null) st.push(curNode.right);
            st.push(curNode);
            if (curNode.left != null) st.push(curNode.left);            
        }
        return ans;
    }
}
```

### 102. 二叉树的层序遍历

* 双 stack

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        Stack<TreeNode> st = new Stack();
        Stack<TreeNode> trans = new Stack();
        List<List<Integer>> ans = new ArrayList();

        if (root == null) {return ans;}
        st.push(root);

        while(!st.empty() || !trans.empty()) {
            while (!st.empty()) {
                trans.push(st.pop());
            }
            List<Integer> tmpList = new ArrayList();
            while (!trans.empty()) {
                TreeNode curNode = trans.pop();
                tmpList.add(curNode.val);
                if (curNode.left != null) st.push(curNode.left);
                if (curNode.right != null) st.push(curNode.right);
            }
            ans.add(tmpList);
        }
        return ans;
    }
}
```

* 单stack

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {

        List<List<Integer>> ans = new ArrayList();
        Queue<TreeNode> que = new LinkedList();

        if (root == null) {return ans;}
        que.add(root);
        while (!que.isEmpty()) {
            int count = que.size();
            List<Integer> tmpList = new ArrayList();
            for (int i = 0; i < count; i++) {
                TreeNode tmpNode = que.remove();
                if (tmpNode.left != null) que.add(tmpNode.left);
                if (tmpNode.right != null) que.add(tmpNode.right);
                tmpList.add(tmpNode.val);
            }
            ans.add(tmpList);
        }
        return ans;
    }
}
```

### 226. 翻转二叉树

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) return root;
        inver(root);
        return root;
    }

    public void inver(TreeNode curNode) {
        if (curNode == null) return;
        // if (curNode.left == null && curNode.right == null) {return;}
        TreeNode tmpNode = curNode.left;
        curNode.left = curNode.right;
        curNode.right = tmpNode;
        inver(curNode.left);
        inver(curNode.right);
    }
}
```



### 101. 对称二叉树

递归如何做

【TODO】

循环如何做

* 栈

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null) return true;
        Queue<TreeNode> que1 = new LinkedList();
        Queue<TreeNode> que2 = new LinkedList();
        if ((root.left == null) != (root.right == null)) return false;
        if (root.left == null && root.right == null) return true;
        que1.add(root.left);
        que2.add(root.right);
        int size1 = que1.size();
        int size2 = que2.size();
        while (size1 == size2 && !que1.isEmpty() && !que2.isEmpty()) {
            for (int i = 0; i < size1; i++) {
                TreeNode tmp1 = que1.remove();
                TreeNode tmp2 = que2.remove();
                if (tmp1.val != tmp2.val) return false;

                if ((tmp1.left == null) != (tmp2.right == null)) return false;
                if ((tmp2.left == null) != (tmp1.right == null)) return false;

                if (tmp1.left != null) que1.add(tmp1.left);
                if (tmp2.right != null) que2.add(tmp2.right);

                if (tmp1.right != null) que1.add(tmp1.right);
                if (tmp2.left != null) que2.add(tmp2.left);
            }
            size1 = que1.size();
            size2 = que2.size();
        }
        if (size1 != size2) return false;
        return true;
    }
}
```

* Leetcode

```java
class Solution {
	public boolean isSymmetric(TreeNode root) {
		if(root==null || (root.left==null && root.right==null)) {
			return true;
		}
		//用队列保存节点
		LinkedList<TreeNode> queue = new LinkedList<TreeNode>();
		//将根节点的左右孩子放到队列中
		queue.add(root.left);
		queue.add(root.right);
		while(queue.size()>0) {
			//从队列中取出两个节点，再比较这两个节点
			TreeNode left = queue.removeFirst();
			TreeNode right = queue.removeFirst();
			//如果两个节点都为空就继续循环，两者有一个为空就返回false
			if(left==null && right==null) {
				continue;
			}
			if(left==null || right==null) {
				return false;
			}
			if(left.val!=right.val) {
				return false;
			}
			//将左节点的左孩子， 右节点的右孩子放入队列
			queue.add(left.left);
			queue.add(right.right);
			//将左节点的右孩子，右节点的左孩子放入队列
			queue.add(left.right);
			queue.add(right.left);
		}
		
		return true;
	}
}

作者：wang_ni_ma
链接：https://leetcode-cn.com/problems/symmetric-tree/solution/dong-hua-yan-shi-101-dui-cheng-er-cha-shu-by-user7/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



### 104. 二叉树的最大深度

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        int layer = 0;

        Queue<TreeNode> que = new LinkedList();
        que.add(root);

        while (!que.isEmpty()) {
            layer++;
            int size = que.size();
            for (int i = 0; i < size; i++) {
                TreeNode curNode = que.remove();
                if (curNode.left != null) {que.add(curNode.left);}
                if (curNode.right != null) {que.add(curNode.right);}
            }
        }
        return layer;
    }
}
```




&nbsp;

---

&nbsp;

## 🔙回 溯

* **【TODO】**

&nbsp;

---

&nbsp;

## 💯贪 心

* **【TODO】**

&nbsp;

---

&nbsp;

## 📡动 态 规 划

* **【TODO】**

&nbsp;

---

&nbsp;

## 🧩图 论

* **【TODO】**

&nbsp;

---

&nbsp;

## 🎯高 级 数 据 结 构

* **【TODO】**
