# 📝My LeetCode Note

## 🗺️路线

* [🔢数组](#数-组) --> [⛓️链表](#%EF%B8%8F链-表) --> [🧾哈希表](#哈-希-表) --> [🔡字符串](#字-符-串) --> [🈯️双指针法](#%EF%B8%8F双-指-针-法)  --> [🎢栈与队列](#栈-与-队-列) --> [🌳树](#树) --> [🔙回溯](#回-溯) --> [💯贪心](#贪-心) --> [📡动态规划](#动-态-规-划) --> [🧩图论](#图-论) --> [🎯高级数据结构](#高-级-数-据-结-构)

按题型刷完后，再从`简单`刷起，做了几个类型题目之后，再慢慢做`中等`题目、`困难`题目。

* 路线 from：[代码随想录](https://programmercarl.com/)

* 题解语言：`Java`

&nbsp;

---
&nbsp;

## 🔢数 组

### 27. 移除元素

* **【TODO】**

### 26. 删除排序数组中的重复项

* **【TODO】**

### 283. 移动零

* **【TODO】**

### [844. 比较含退格的字符串](./Solutions/844.比较含退格的字符串.md)

### [977. 有序数组的平方](./Solutions/977.有序数组的平方.md)

### [209. 长度最小的子数组](./Solutions/209.长度最小的子数组.md)

### [904. 水果成篮](./Solutions/904.水果成篮.md)

### [76. 最小覆盖子串](./Solutions/76.最小覆盖子串.md)

### [59. 螺旋矩阵 II](./Solutions/59.螺旋矩阵II.md)

&nbsp;

---

&nbsp;

## ⛓️链 表

### [203. 移除链表元素](./Solutions/203.移除链表元素.md)

### [707. 设计链表](./Solutions/707.设计链表.md)

### [206. 反转链表](./Solutions/206.反转链表.md)

### [24. 两两交换链表中的节点](./Solutions/24.两两交换链表中的节点.md)

### [19. 删除链表的倒数第 N 个结点](./Solutions/19.删除链表的倒数第N个结点.md)

### [面试题 02.07. 链表相交](./Solutions/面试题02.07.链表相交.md)

### [142. 环形链表II](./Solutions/142.环形链表II.md)

&nbsp;

---

&nbsp;

## 🧾哈 希 表

### 基础：

**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法**。

但是哈希法也是**牺牲了空间换取了时间**，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。

如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！

[( from 代码随想录 哈希表理论基础 )](https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%89%E7%A7%8D%E5%93%88%E5%B8%8C%E7%BB%93%E6%9E%84)

&nbsp;

### [242. 有效的字母异位词](./Solutions/242.有效的字母异位词.md)

### [383. 赎金信](./Solutions/383.赎金信.md)

### [49. 字母异位词分组](./Solutions/49.字母异位词分组.md)

### [438. 找到字符串中所有字母异位词](./Solutions/438.找到字符串中所有字母异位词.md)

### [349. 两个数组的交集](./Solutions/350.两个数组的交集II.md)

### [202. 快乐数](./Solutions/202.快乐数.md)

### 1. 两数之和

* **【TODO】**

### [454. 四数相加II](./Solutions/454.四数相加II.md)

### [15. 三数之和](./Solutions/15.三数之和.md)

### 18. 四数之和

* **【TODO】**

&nbsp;

---

&nbsp;

## 🔡字 符 串

### 344. 反转字符串

* **【TODO】**

### [541. 反转字符串II](./Solutions/541.反转字符串II.md)

### [剑指Offer 05. 替换空格](./Solutions/剑指Offer05.替换空格.md)

### [151. 翻转字符串里的单词](./Solutions/151.翻转字符串里的单词.md)

### [剑指Offer58-II. 左旋转字符串](./Solutions/剑指Offer58-II.左旋转字符串.md)

### [28. 实现 strStr()](./Solutions/28.实现strStr().md)

### [459. 重复的子字符串](./Solutions/459.重复的子字符串.md)

&nbsp;

---

&nbsp;

## 🈯️双 指 针 法

### [27. 移除元素](./Solutions/27.移除元素.md)

### [344. 反转字符串](./Solutions/344.反转字符串.md)

### 151.翻转字符串里的单词

### 206.反转链表

### 19.删除链表的倒数第N个节点

### 面试题 02.07. 链表相交

### 142.环形链表II

### 15. 三数之和

### 18. 四数之和

&nbsp;

---

&nbsp;


## 🎢栈 与 队 列

### [232. 用栈实现队列](./Solutions/232.用栈实现队列.md)

### [225. 用队列实现栈](./Solutions/225.用队列实现栈.md)

### [20. 有效的括号](./Solutions/20.有效的括号.md)

### [1047. 删除字符串中的所有相邻重复项](./Solutions/1047.删除字符串中的所有相邻重复项.md)

### [150. 逆波兰表达式求值](./Solutions/150.逆波兰表达式求值.md)

### [239. 滑动窗口最大值](./Solutions/239.滑动窗口最大值.md)

### [347. 前K个高频元素](./Solutions/347.前K个高频元素.md)

### 栈与队列总结



* **【TODO】**

&nbsp;

---

&nbsp;

## 🌳树

### [144. 二叉树的前序遍历](./Solutions/144.二叉树的前序遍历.md)

### [145. 二叉树的后序遍历](./Solutions/145.二叉树的后序遍历.md)

### [94. 二叉树的中序遍历](./Solutions/94.二叉树的中序遍历.md)

### [102. 二叉树的层序遍历](./Solutions/102.二叉树的层序遍历.md)

### [226. 翻转二叉树](./Solutions/226.翻转二叉树.md)

### [101. 对称二叉树](./Solutions/101.对称二叉树.md)

### [104. 二叉树的最大深度](./Solutions/104.二叉树的最大深度.md)

### 559. n叉树的最大深度

### [111. 二叉树的最小深度](./Solutions/111.二叉树的最小深度.md)

### [222. 完全二叉树的节点个数](./Solutions/222.完全二叉树的节点个数.md)

### [110. 平衡二叉树](./Solutions/110.平衡二叉树.md)

### [257. 二叉树的所有路径](./Solutions/257.二叉树的所有路径.md)

### [404. 左叶子之和](./Solutions/404.左叶子之和.md)

### [513. 找树左下角的值](./Solutions/513.找树左下角的值.md)

### [112. 路径总和](./Solutions/112.路径总和.md)

### 106. 从中序与后序遍历序列构造二叉树

### [654. 最大二叉树](./Solutions/654.最大二叉树.md)

### [617. 合并二叉树](./Solutions/617.合并二叉树.md)

### 700. 二叉搜索树中的搜索

```java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        if (root == null) return null;
        Queue<TreeNode> que = new LinkedList();
        que.add(root);
        while (!que.isEmpty()) {
            TreeNode cur = que.remove();
            if (cur.val == val) return cur;
            if (cur.left != null) que.add(cur.left);
            if (cur.right != null) que.add(cur.right);
        }
        return null;
    }
}
```

### 98. 验证二叉搜索树

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        if (root == null) return true;
        LinkedList<Integer> log = new LinkedList();
        midTra(root, log);
        if (log.size() < 1) return true;
        for (int i = 1; i < log.size(); i++) {
            if (log.get(i) <= log.get(i - 1)) return false;
        }
        return true;
    }

    public void midTra(TreeNode root, LinkedList log) {
        if (root == null) return ;
        midTra(root.left, log);
        log.add(root.val);
        midTra(root.right, log);
    }
}
```

### 530. 二叉搜索树的最小绝对差

```java
class Solution {
    LinkedList<Integer> log = new LinkedList();
    public int getMinimumDifference(TreeNode root) {
        long min = Long.MAX_VALUE;
        inorder(root);
        for (int i = 1; i < log.size(); i++) {
            long value = log.get(i) - log.get(i - 1);
            if (value < 0) value = -value;
            if (value < min) min = value;
        }
        return (int)min;
    }

    public void inorder(TreeNode root) {
        if (root == null) return;
        inorder(root.left);
        log.add(root.val);
        inorder(root.right);
    }
}
```

### 501. 二叉搜索树中的众数

```java
class Solution {
    TreeNode pre = null;
    HashMap<Integer, Integer> freq = new HashMap();
    public int[] findMode(TreeNode root) {
        inorder(root);
        int max = 0;
        for (int k : freq.keySet()) {
            int fre = freq.get(k);
            if (fre > max) {
                max = fre;
            }
        }
        int[] ans = new int[freq.size()];
        int index = 0;
        for (int k : freq.keySet()) {
            int fre = freq.get(k);
            if (fre == max) {
                ans[index++] = k;
            }
        }
        return Arrays.copyOfRange(ans, 0, index);
    }

    public void inorder(TreeNode root) {
        if (root == null) return;
        inorder(root.left);
        freq.put(root.val, freq.getOrDefault(root.val, 0) + 1);
        inorder(root.right);
    }
}
```

### 236. 二叉树的最近公共祖先

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    TreeNode pub;
    boolean foundFirst = false;
    boolean isDone = false;
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        order(root, p, q);
        return pub;
    }

    public void order(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null) return;

        //中序搜索 左子节点递归
        if (!isDone) order(root.left, p, q);

        if (!isDone) {
            //未搜索到第一个节点 中序遍历
            if (!foundFirst) {
                //搜索第一个节点
                if (root.val == p.val || root.val == q.val) {
                    foundFirst = true;
                    pub = root;
                    if (root.left == null && root.right == null) {
                    //是叶子结点 直接结束递归

                    return;
                    }
                }
            }
            //已找到第一个节点
            else {
                if (isFather(pub, root)) {
                    pub = root;
                }
                if (root.val == p.val || root.val == q.val) {
                    //已经搜索到第二个节点 标记flag isDone 结束之后的所有递归
                    isDone = true;
                    return;
                }
            }
        }
        //右子节点中序遍历递归
        if (!isDone) order(root.right, p, q);
    }

    //判断 son 是否在 father 的子树中
    public boolean isFather(TreeNode son, TreeNode father) {
        if (father == null || son == null) { return false; }
        if (father.left != null && father.left.val == son.val) { return true; }
        if (father.right != null && father.right.val == son.val) { return true; }
        return isFather(son, father.left) || isFather(son, father.right);
    }
}
```
* Solution 2

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */

class Solution {
    TreeNode ans = null;
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        tra(root, p, q);
        return ans;
    }

    public boolean tra(TreeNode cur, TreeNode p, TreeNode q) {
        if (cur == null) return false;
        boolean lhave = tra(cur.left, p, q);
        boolean rhave = tra(cur.right, p, q);
        //左右各一个节点 则该节点为目标节点
        if (lhave && rhave) { ans = cur; }
        //当前节点为一个，子树含一个，则该节点为目标节点
        if ((cur == p) || (cur == q) && (lhave || rhave)) { ans = cur; }
        return lhave || rhave || (cur == p) || (cur == q);
    }
}
```

### 235. 二叉搜索树的最近公共祖先

```java

```

### 701.二叉搜索树中的插入操作

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if (root == null) { return new TreeNode(val); }
        TreeNode tar = new TreeNode(val);
        locate(root, tar);
        return root;
    }

    public void locate(TreeNode root, TreeNode tar) {
        TreeNode cur = root;
        if (tar.val < cur.val) {
            if (cur.left != null) {
                locate(cur.left, tar);
            }
            else {
                cur.left = tar;
            }
        }
        else if (tar.val > cur.val) {
            if (cur.right != null) {
                locate(cur.right, tar);
            }
            else {
                cur.right = tar;
            }
        }
    }
}
```

### 450.删除二叉搜索树中的节点

```java
此题和669 重点在每次递归的返回值 是该节点本身（涉及删除该节点 则若需要删除 就返回删除后的替代节点）

```java
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        if (root == null) return null;

        if (root.val == key) {
            // 情况1、2：被删除节点没有子节点、没有左子树、没有右子树
            if (root.left == null) return root.right;
            if (root.right == null) return root.left;
            // 情况3：被删除节点既有左子树，又有右子树：取右子树的最小节点取代被删除节点，并删除右子树的最小节点
            TreeNode minNodeOfRight = findMinNode(root.right);
            root.val = minNodeOfRight.val;
            root.right = deleteNode(root.right, minNodeOfRight.val);
        } else if (root.val < key) {
            root.right = deleteNode(root.right, key);
        } else if (root.val > key) {
            root.left = deleteNode(root.left, key);
        }

        return root;
    }

    private TreeNode findMinNode(TreeNode node) {
        while (node.left != null) {
            node = node.left;
        }
        return node;
    }
}

作者：ar-lai
链接：https://leetcode-cn.com/problems/delete-node-in-a-bst/solution/javachao-jian-dan-de-er-fen-sou-suo-di-g-z83v/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

* 仿写

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode deleteNode(TreeNode cur, int key) {
        if (cur == null) return null;

        if (cur.val == key) {
            //cur 只有单子节点或无子节点
            if (cur.left == null) return cur.right;
            if (cur.right == null) return cur.left;

            //含有两个子节点
            TreeNode maxOfLeft = cur.left;
            while (maxOfLeft.right != null) {
                maxOfLeft = maxOfLeft.right;
            }
            cur.val = maxOfLeft.val;
            cur.left = deleteNode(cur.left, maxOfLeft.val);
        }
        else if (cur.val < key) {
            cur.right = deleteNode(cur.right, key);
        }
        else if (cur.val > key) {
            cur.left = deleteNode(cur.left, key);
        }
        return cur;
    }
}
```

### 669. 修剪二叉搜索树

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode trimBST(TreeNode root, int low, int high) {
        if (root == null) return null;
        int value = root.val;
        if (value < low) {
            root = trimBST(root.right, low, high);
        }
        else if (value > high) {
            root = trimBST(root.left, low, high);
        }
        else {
            root.left = trimBST(root.left, low, high);
            root.right = trimBST(root.right, low, high);
        }
        return root;
    }
}
```

### 108.将有序数组转换为二叉搜索树

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        TreeNode start = new TreeNode();
        make(nums, start, 0, nums.length - 1);
        return start;
    }

    public void make(int[] nums, TreeNode cur, int low, int high) {
        int mid = (high + low) / 2;
        if (low > high) { return; }

        cur.val = nums[mid];
        if (low == high) { return; }

        if (high - low == 1) {
            cur.right = new TreeNode(); 
            make(nums, cur.right, high, high);
            return;
        }
		//high - low > 1:
        cur.left = new TreeNode(); 
        cur.right = new TreeNode(); 

        make(nums, cur.left, low, mid - 1);
        make(nums, cur.right, mid + 1, high);
    }
}
```

### 538.把二叉搜索树转换为累加树

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int sum = 0;
    // right - root - left
    public TreeNode convertBST(TreeNode root) {
        if (root == null) return null;
        //right
        convertBST(root.right);
        //root
        sum += root.val;
        root.val = sum;

        //left
        convertBST(root.left);
        return root;
    }
}
```

&nbsp;

---

&nbsp;

## 🔙回 溯

&nbsp;

### 77. 组合

```java
class Solution {
    LinkedList<Integer> base = new LinkedList();
    List<List<Integer>> ans = new ArrayList();
    public List<List<Integer>> combine(int n, int k) {
        comb(n, k, 1);
        return ans;
    }

    public void comb(int n, int k, int start) {
        if (base.size() == k) {
            ans.add(new ArrayList(base));
            return;
        }

        for (int i = start; i <= n; i++) {
            base.add(i);
            comb(n, k, i + 1);
            base.removeLast();
        }
    }
}
```



### 216. 组合总和 III

```java
class Solution {
    LinkedList<Integer> base = new LinkedList();
    ArrayList<List<Integer>> ans = new ArrayList();
    int sum;
    public List<List<Integer>> combinationSum3(int k, int n) {
        comb(k, n, 1);
        return ans;
    }

    public void comb(int k, int n, int start) {
        // end condition: 满足条件
        if (sum == n && base.size() == k) {
            ans.add(new ArrayList(base));
            return;
        }
        //end condition: 无法满足条件
        if (sum > n || base.size() >= k) {
            return;
        }

        //循环体
        for (int i = start; i < 10; i++) {
            base.add(i);
            sum += i;
            comb(k, n, i + 1);
            base.removeLast();
            sum -= i;
        }
    }
}
```

### 17. 电话号码的字母组合

```java
class Solution {
    ArrayList<String> ans = new ArrayList();
    StringBuilder base = new StringBuilder();
    String[] dic = new String[10];
    public List<String> letterCombinations(String digits) {
        dic[2] = "abc";
        dic[3] = "def";
        dic[4] = "ghi";
        dic[5] = "jkl";
        dic[6] = "mno";
        dic[7] = "pqrs";
        dic[8] = "tuv";
        dic[9] = "wxyz";
        combNumber(digits, 0);
        return ans;
    }

    public void combNumber(String digits, int indexOfDigits) {
        //end condition
        if (indexOfDigits >= digits.length()) {
            //防止添加空的 String 进 ans,导致结果为: [""] 而不是: []
            if (base.length() > 0) {
                ans.add(base.toString());
            }
            return;
        }

        //backtracking body
        int callNumber = digits.charAt(indexOfDigits) - 48;
        for (int i = 0; i < dic[callNumber].length(); i++) {
            base.append(dic[callNumber].charAt(i));
            combNumber(digits, indexOfDigits + 1);
            //back
            base.deleteCharAt(base.length() - 1);
        }
    }
}
```

### 39. 组合总和

```java
class Solution {
    ArrayList<List<Integer>> ans = new ArrayList();
    LinkedList<Integer> base = new LinkedList();

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        comb(candidates, target, 0, 0);
        return ans;
    }

    public void comb(int[] candidates, int target, int sum, int index) {
        //end condition
        if (sum == target) {
            ans.add(new ArrayList(base));
            return;
        }
        else if (sum > target || index >= candidates.length) {
            return;
        }

        //backTracking body
            
        sum += candidates[index];
        base.add(candidates[index]);
        comb(candidates, target, sum, index);
        
        base.removeLast();
        sum -= candidates[index];

        comb(candidates, target, sum, index + 1);
    }
}
```

### 40. 组合总和II

基础版 超时：

```java
class Solution {
    LinkedList<Integer> base = new LinkedList();
    ArrayList<List<Integer>> ans = new ArrayList();
    HashSet<List<Integer>> set = new HashSet();

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        comb(candidates, target, 0, 0);
        for (List<Integer> tmp : set) {
            ans.add(tmp);
        }
        return ans;
    }

    public void comb(int[] candidates, int target, int sum, int start) {
        //end condition
        if (sum == target) {
            ArrayList<Integer> tmp = new ArrayList(base);
            tmp.sort(Comparator.naturalOrder());
            if (!set.contains(tmp)) {
                set.add(tmp);
            }
            return;
        }
        else if (sum >= target) {
            return;
        }

        //backTracking
        for (int i = start; i < candidates.length; i++) {
            sum += candidates[i];
            base.add(candidates[i]);
            comb(candidates, target, sum, i + 1);
            sum -= candidates[i];
            base.removeLast();
        }
    }
}
```

* 改进

```java
class Solution {
    LinkedList<Integer> base = new LinkedList();
    ArrayList<List<Integer>> ans = new ArrayList();

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        comb(candidates, target, 0, 0);
        return ans;
    }

    public void comb(int[] candidates, int target, int sum, int start) {
        boolean isBigger = false;
        int last = 0;
        int valueOfLast = 0;
        //end condition
        if (sum == target) {
            ArrayList<Integer> tmp = new ArrayList(base);
            ans.add(tmp);

            isBigger = true;
            return;
        }
        else if (sum > target) {
            isBigger = true;
            return;
        }

        //backTracking
        for (int i = start; i < candidates.length; i++) {
            if (i == start) {
                last = start;
                valueOfLast = candidates[last];
            }
            else if (candidates[i] == valueOfLast) { continue; }
            last = i;
            valueOfLast = candidates[last];
            sum += candidates[i];
            base.add(candidates[i]);
            comb(candidates, target, sum, i + 1);
            sum -= candidates[i];
            base.removeLast();
        }
    }
}
```

### 131. 分割回文串

```java
class Solution {
    LinkedList<String> base = new LinkedList();
    ArrayList<List<String>> ans = new ArrayList();

    public List<List<String>> partition(String s) {
        backtrace(s, 0);
        return ans;

    }

    public void backtrace(String s, int start) {
        //end condition
        if (start == s.length()) {
            ans.add(new ArrayList(base));
            return;
        }

        //back trace body
        for (int i = start; i < s.length(); i++) {
            String sub = s.substring(start, i + 1);
            if (isPalindrome(sub)) {
                base.add(sub);
                backtrace(s, i + 1);
                base.removeLast();
            }
        }
    }

    public boolean isPalindrome(String s) {
        int len = s.length();
        if (len == 1) { return true; }
        int left = 0;
        int right = len - 1;
        while (left < right) {
            if (s.charAt(left++) != s.charAt(right--)) { return false; }
        }
        return true;
    }
}
```

### 93. 复原IP地址

```java
class Solution {
    LinkedList<String> base = new LinkedList();
    ArrayList<String> ans = new ArrayList();

    public List<String> restoreIpAddresses(String s) {
        backtrace(s, 0);
        return ans;
    }

    public void backtrace(String s, int start) {
        //end condition
        if (start == s.length() && base.size() == 4) {
            ans.add(concateIP(base));
            return;
        }
        // 两种条件退出：1. 已遍历完 s 但未凑够4段ip； 2. 已凑够4段ip但s未遍历完
        else if(start == s.length() ^ base.size() == 4) { return; }

        //backtrace body
        for (int i = start; i < s.length(); i++) {
            if (i - start == 3) { break; }
            String tmp = s.substring(start, i + 1);
            int num = isIP(tmp);
            if (num != -1) {
                base.add(tmp);
                backtrace(s, i + 1);
                base.removeLast();
            }
        }
    }

    //判断所截出的 String 是否为合法IP，不合法则返回 -1； 合法则返回对应 int 值
    public int isIP(String s) {
        if (s.length() < 1) { return -1; }
        int num = Integer.valueOf(s);
        if (s.charAt(0) == '0' && s.length() > 1) { return -1; }
        if (num < 0 || num > 255) { return -1; }
        return num;
    }

    //用保存4段IP String 的 List 拼接出IP String
    public String concateIP(LinkedList<String> base) {
        StringBuilder sb = new StringBuilder();
        for (String s : base) {
            sb.append(s);
            sb.append('.');
        }
        sb.deleteCharAt(sb.length() - 1);
        return sb.toString();
    }
}
```

### 78. 子集问题

* 去重问题 全集如何添加

```java
class Solution {
    LinkedList<Integer> base = new LinkedList();
    ArrayList<List<Integer>> ans = new ArrayList();
    public List<List<Integer>> subsets(int[] nums) {
        ans.add(new ArrayList());
        if (nums.length == 0) {
            return ans;
        }
        List<Integer> allnums = Arrays.asList(nums);
        ans.add(allnums);
        if (nums.length == 0) {
            return ans;
        }
        backtrace(nums, 0);
        return ans;
    }

    public void backtrace(int[] nums, int start) {
        //end condition
        if (base.size() == nums.length) {
            return;
        }

        //backtrace body
        for (int i = start; i < nums.length; i++) {
            base.add(nums[i]);
            ans.add(new ArrayList(base));
            backtrace(nums, i + 1);
            base.removeLast();
        }
    }
}
```

* HashSet 去重

```java
class Solution {
    LinkedList<Integer> base = new LinkedList();
    ArrayList<List<Integer>> ans = new ArrayList();
    HashSet<List<Integer>> set = new HashSet();
    public List<List<Integer>> subsets(int[] nums) {
        ans.add(new ArrayList());
        set.add(new ArrayList());
        if (nums.length == 0) {
            return ans;
        }

        backtrace(nums, 0);
        return ans;
    }

    public void backtrace(int[] nums, int start) {
        //end condition
        if (base.size() == nums.length) {
            return;
        }

        //backtrace body
        for (int i = start; i < nums.length; i++) {
            base.add(nums[i]);
            if (!set.contains(base)) {
                ans.add(new ArrayList(base));
                set.add(new ArrayList(base));
            }
            backtrace(nums, i + 1);
            base.removeLast();
        }
    }
}
```

### 90. 子集II

```java
class Solution {
    LinkedList<Integer> base = new LinkedList();
    ArrayList<List<Integer>> ans = new ArrayList();
    HashSet<List<Integer>> set = new HashSet();
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        ans.add(new ArrayList());
        set.add(new ArrayList());
        if (nums.length == 0) {
            return ans;
        }
        Arrays.sort(nums);

        backtrace(nums, 0);
        return ans;
    }

    public void backtrace(int[] nums, int start) {
        //end condition
        if (base.size() == nums.length) {
            return;
        }

        //backtrace body
        for (int i = start; i < nums.length; i++) {
            base.add(nums[i]);
            if (!set.contains(base)) {
                ans.add(new ArrayList(base));
                set.add(new ArrayList(base));
            }
            backtrace(nums, i + 1);
            base.removeLast();
        }

    }
}
```

### 491. 递增子序列

```java
class Solution {
    ArrayList<List<Integer>> ans = new ArrayList();
    LinkedList<Integer> base = new LinkedList();
    HashSet<List<Integer>> set = new HashSet();
    public List<List<Integer>> findSubsequences(int[] nums) {
        for (int i = 0; i < nums.length - 1; i++) {
            backtrace(nums, i, i);
        }
        return ans;
    }

    public void backtrace(int[] nums, int start, int cur) {
        //end condition
        if (cur >= nums.length) {
            return;
        }
        //backtrace body
        //第一位输入
        if (start == cur) {
            base.add(nums[cur]);
            backtrace(nums, start, cur + 1);
            base.removeLast();
        }
        else if ((nums[cur] >= base.peekLast())) {
            base.add(nums[cur]);
            if (!set.contains(base)) {
                set.add(new ArrayList(base));
                ans.add(new ArrayList(base));
            }
            backtrace(nums, start, cur + 1);
            base.removeLast();
        }
        if (start != cur) {
            backtrace(nums, start, cur + 1);
        }
    }
}
```

* 去重思路：

> 那如何保证没有重复呢？我们需要给「不选择」做一个限定条件，只有当**当前的元素不等于上一个选择的元素**的时候，才考虑不选择当前元素，直接递归后面的元素。因为如果有两个相同的元素，我们会考虑这样四种情况：
>
> 1.前者被选择，后者被选择
> **2.前者被选择，后者不被选择**
> **3.前者不被选择，后者被选择**
> 4.前者不被选择，后者不被选择
> 其中第二种情况和第三种情况其实是等价的，我们这样限制之后，**舍弃了第二种，保留了第三种**，于是达到了去重的目的。
>
> 作者：LeetCode-Solution
> 链接：https://leetcode-cn.com/problems/increasing-subsequences/solution/di-zeng-zi-xu-lie-by-leetcode-solution/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



```java
class Solution {
    List<Integer> temp = new ArrayList<Integer>();
    List<List<Integer>> ans = new ArrayList<List<Integer>>();

    public List<List<Integer>> findSubsequences(int[] nums) {
        dfs(0, Integer.MIN_VALUE, nums);
        return ans;
    }

    public void dfs(int cur, int last, int[] nums) {
        if (cur == nums.length) {
            if (temp.size() >= 2) {
                ans.add(new ArrayList<Integer>(temp));
            }
            return;
        }
        if (nums[cur] >= last) {
            temp.add(nums[cur]);
            dfs(cur + 1, nums[cur], nums);
            temp.remove(temp.size() - 1);
        }
        if (nums[cur] != last) {
            dfs(cur + 1, last, nums);
        }
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/increasing-subsequences/solution/di-zeng-zi-xu-lie-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

### 46. 全排列

```java
class Solution {
    LinkedList<Integer> base = new LinkedList();
    ArrayList<List<Integer>> ans = new ArrayList();
    HashSet<Integer> set = new HashSet();
    public List<List<Integer>> permute(int[] nums) {
        dfs(nums, 0);
        return ans;
    }

    public void dfs(int[] nums, int count) {
        //end condition
        if (set.size() == nums.length) {
            ans.add(new ArrayList(base));
            return;
        }
        if (count == nums.length) { return; }

        //backTrace body
        for (int i = 0; i < nums.length; i++) {
            if (!set.contains(nums[i])) {
                base.add(nums[i]);
                set.add(nums[i]);
                dfs(nums, count + 1);
                base.removeLast();
                set.remove(nums[i]);
            }
        }
    }
}
```

### 47. 全排列II

```java
class Solution {
    LinkedList<Integer> base = new LinkedList();
    ArrayList<List<Integer>> ans = new ArrayList();
    HashMap<Integer, Integer> map = new HashMap();
    HashMap<Integer, Integer> table = new HashMap();
    HashSet<Integer> set = new HashSet();
    HashSet<List<Integer>> dup = new HashSet();
    public List<List<Integer>> permuteUnique(int[] nums) {
        for (int n : nums) {
            table.put(n, table.getOrDefault(n, 0) + 1);
        }
        dfs(nums, 0);
        return ans;
    }

    public void dfs(int[] nums, int count) {
        //end condition
        if (count == nums.length) {
            if (!dup.contains(base)) {
                ans.add(new ArrayList(base));
                dup.add(new ArrayList(base));
            }
            return;    
        }

        //backTrace body
        for (int i = 0; i < nums.length; i++) {
            if (!map.containsKey(nums[i]) || table.get(nums[i]) != map.get(nums[i])) {
                base.add(nums[i]);
                map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);
                dfs(nums, count + 1);
                base.removeLast();
                map.put(nums[i], map.get(nums[i]) - 1);
            }
        }
    }
}
```

```java
class Solution {
    //存放结果
    List<List<Integer>> result = new ArrayList<>();
    //暂存结果
    List<Integer> path = new ArrayList<>();

    public List<List<Integer>> permuteUnique(int[] nums) {
        boolean[] used = new boolean[nums.length];
        Arrays.fill(used, false);
        Arrays.sort(nums);
        backTrack(nums, used);
        return result;
    }

    private void backTrack(int[] nums, boolean[] used) {
        if (path.size() == nums.length) {
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            // used[i - 1] == true，说明同⼀树⽀nums[i - 1]使⽤过
            // used[i - 1] == false，说明同⼀树层nums[i - 1]使⽤过
            // 如果同⼀树层nums[i - 1]使⽤过则直接跳过
            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {
                continue;
            }
            //如果同⼀树⽀nums[i]没使⽤过开始处理
            if (used[i] == false) {
                used[i] = true;//标记同⼀树⽀nums[i]使⽤过，防止同一树支重复使用
                path.add(nums[i]);
                backTrack(nums, used);
                path.remove(path.size() - 1);//回溯，说明同⼀树层nums[i]使⽤过，防止下一树层重复
                used[i] = false;//回溯
            }
        }
    }
}

作者：carlsun-2
链接：https://leetcode-cn.com/problems/permutations-ii/solution/dai-ma-sui-xiang-lu-dai-ni-xue-tou-hui-s-ki1h/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

### 332. 重新安排行程

```java

```

### 51. N皇后

```java

```

### 37. 解数独

```java

```

&nbsp;

---

&nbsp;

## 💯贪 心

&nbsp;

### 455. 分发饼干

```java
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        int count = 0;
        int j = 0;
        for (int i = 0; i < s.length && j < g.length; i++) {
            if (s[i] >= g[j]) {
                count++;
                j++;
            }
        }
        return count;
    }
}
```

### 376. 摆动序列

尝试回溯， **超时**：

```java
class Solution {
    int max = 0;
    public int wiggleMaxLength(int[] nums) {
        dfs(nums, 0, -1, -1, 0);
        return max;
    }
    //n2: 上一位 符合条件的 索引, -1 表示无
    //n1: 上上一位符合条件的索引, -1 表示无
    //index: 当前索引
    //count: 符合条件的序列长度
    public void dfs(int[] nums, int index, int n2, int n1, int count) {
        
        //end condition
        if (index == nums.length) {
            max = max < count ? count : max;
            return;
        }
        //剪枝
        if (count + nums.length - index < max) {
            return;
        }

        //backTrace
        //n2 == -1，序列为空
        if (n2 == -1) {
            dfs(nums, index + 1, index, -1, 1);
            dfs(nums, index + 1, -1, -1, 0);
        }
        else {
            //n1 == -1，序列只有一位
            if (n1 == -1) {
                //序列添加第二位时 只需要与第一位不相等即可
                if (nums[n2] != nums[index]) {
                    dfs(nums, index + 1, index, n2, 2);
                }
            dfs(nums, index + 1, n2, -1, 1);

            }
            //index 的前两位差值为正数
            else if (nums[n2] - nums[n1] > 0) {
                if (nums[index] - nums[n2] < 0) {
                    dfs(nums, index + 1, index, n2, count + 1);
                }
                dfs(nums, index + 1, n2, n1, count);
            }
            //index 的前两位差值为负数
            else if (nums[n2] - nums[n1] < 0) {
                if (nums[index] - nums[n2] > 0) {
                    dfs(nums, index + 1, index, n2, count + 1);
                }
                dfs(nums, index + 1, n2, n1, count);
            }
        }
    }
}
```

* 内存超出限制

```java
class Solution {
    Queue<boolean[]> que = new LinkedList();
    public int wiggleMaxLength(int[] nums) {
        boolean[] isMark = new boolean[nums.length];
        Arrays.fill(isMark, true);
        que.add(isMark);
        return bfs(nums);
    }

    public int bfs(int[] nums) {
        int count = 0;
        while (!que.isEmpty()) {
            boolean[] cur = que.remove();
            //已找到
            if (isWiggle(nums, cur)) {
                count = 0;
                for (boolean mark : cur) {
                    if (mark) { count++; }
                }
                return count;
            }
            //该组合cur不是答案，在cur基础上添加下一层的 isMark 表
            for (int i = 0; i < nums.length; i++) {
                if (cur[i]) {
                    boolean[] tmp = Arrays.copyOf(cur, cur.length);
                    tmp[i] = false;
                    que.add(tmp);
                }
            }
        }
        return count;
    }

    public boolean isWiggle(int[] nums, boolean[] isMark) {
        int n1 = -1;
        int n2 = -1;
        //get first index
        for (int i = 0; i < isMark.length; i++) {
            //find first n1
            if (n1 == -1) {
                if (isMark[i]) {
                    n1 = i;
                    continue;
                }
            }
            //find first n2
            else if (n2 == -1) {
                if (isMark[i]) {
                    n2 = i;
                    break;
                }
            }            
        }
        if (n2 == -1) { return true; }
        else if (nums[n1] == nums[n2]) { return false; }

        for (int i = n2 + 1; i < isMark.length; i++) {
            if (isMark[i]) {
                if (nums[i] == nums[n2]) { return false; }
                if (nums[n2] > nums[n1] && nums[i] > nums[n2]) {
                    return false;
                }
                if (nums[n2] < nums[n1] && nums[i] < nums[n2]) {
                    return false;
                }
                n1 = n2;
                n2 = i;
            }
        }
        return true;
    }
}
```

### 53. 最大子序和

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int len = nums.length;
        if (len == 1) { return nums[0]; }

        int[] comb = new int[len];
        int index = 0;
        for (int i = 0; i < len; i++) {
            if (nums[i] == 0) {
                for (i; i < len; i++) {
                    if (nums[i] == 0) {
                        continue;
                    }
                    else {
                        comb[index++] = 0;
                        i--;
                    }
                }
            }
            else if (nums[i] > 0) {
               int sum = nums[i];
               for (i; i < len; i++) {
                   if (nums[i] >= 0) {
                       sum += nums[i];
                   }
                   else {
                       comb[index++] = sum;
                       i--;
                       continue;
                   }
               }
            }
            else if (nums[i] < 0) {
                int sum = nums[i];
                for (i; i < len; i++) {
                    if (nums[i] < 0) {
                        sum += nums[i];
                   }
                   else {
                       comb[index++] = sum;
                       i--;
                       continue;
                   }
               }
            }
        }
         int max = comb[0];
         int start = 0;
        if (comb[start] == 0) {
                i++;
                j++;
                if (comb[start] < 0) {
                    i++;
                    j++;
                }
            }
         for (int i = 0, int j = 0; i <= index, j <= index; i++, j++) {
            
        }



    }
}
```

超时

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int len = nums.length;
        if (len == 1) { return nums[0]; }
        
        int max = nums[0];
        int[] comb = new int[len];
        int index = 0;
        //求和：将相邻正数合并为一个数，相邻负数合并为一个数
        for (int i = 0; i < len; i++) {
            if (nums[i] == 0) {
                for ( ; i < len; i++) {
                    if (nums[i] == 0) {
                        max = Math.max(nums[i], max);
                        continue;
                    }
                    else {
                        comb[index] = 0;
                        index++;
                        i--;
                        break;
                    }
                }
            }
            else if (nums[i] > 0) {
                for ( ; i < len; i++) {
                    if (nums[i] >= 0) {
                        comb[index] += nums[i];
                        max = Math.max(nums[i], max);
                    }
                    else {
                        index++;
                        i--;
                        break;
                   }
               }
            }
            else if (nums[i] < 0) {
                for ( ; i < len; i++) {
                    if (nums[i] < 0) {
                        comb[index] += nums[i];
                        max = Math.max(nums[i], max);
                    }
                    else {
                        index++;
                        i--;
                        break;
                    }
                }
            }
        }

        int sum;
        for (int i = 0; i <= index; i++) {
            sum = 0;
            for (int j = i; j <= index; j++) {
                sum += comb[j];
                max = Math.max(sum, max);
            }
        }
        return max;
    }
}
```

DP

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int len = nums.length;
        if (len == 1) { return nums[0]; }

        int[] dp = new int[len];
        dp[0] = nums[0];
        int sum = nums[0];
        for (int i = 1; i < len; i++) {
            dp[i] = Math.max(nums[i] + dp[i - 1], nums[i]);
        }
        int max = dp[0];
        for (int x : dp) {
            max = Math.max(max, x);
        }
        return max;
    }
}
```

### 122. 买卖股票的最佳时机II

```java
class Solution {
    public int maxProfit(int[] prices) {
        int len = prices.length;
        if (len == 1) { return 0; }
        //判断是为否单调递减数组
        boolean isDes = true;
        for (int i = 1; i < len; i++) {
            if (prices[i] > prices[i - 1]) {
                isDes = false;
                break;
            }
        }
        //单调递减 最大利润为0
        if (isDes) { return 0; }

        //earning[] 表示 今天比上一天的收益
        int[] earning = new int[len];
        earning[0] = 0;
        int sum = 0;
        for (int i = 1; i < len; i++) {
            //记录所有的比上一天大的差值 若小于 则卖掉 故不用记录到sum中
            if (prices[i] >= prices[i - 1]) {
                earning[i] = prices[i] - prices[i - 1];
                sum += earning[i];
            }
        }
        return sum;
    }
}
```

### 55. 跳跃游戏

```java
class Solution {
    public boolean canJump(int[] nums) {
        int len = nums.length;
        if (len == 1) { return true; }
        int curLong = 0;
        int max = 0;
        for (int i = 0; i < len; i++) {
            //
            if (max >= i) {
                curLong = nums[i] + i;
                max = Math.max(max, curLong);
            }
            else {
                return false;
            }
        }
        return true;
    }
}
```

### 45. 跳跃游戏II

```java
class Solution {
    public int jump(int[] nums) {
        int len = nums.length;
        if (len == 1) { return 0; }
        int max = nums[0];
        int curMax = nums[0];
        int count = 1;
        if (max >= len) { return 1; }
        
        int i = 0;
        while (max < len - 1) {
            for (int j = i; j <= max; j++) {
                if (nums[j] + j > curMax) {
                    curMax = nums[j] + j;
                    i = j;
                }
            }
            max = curMax;
            count++;
        }
        return count;
    }
}
```

* 官方

```java
class Solution {
    public int jump(int[] nums) {
        int length = nums.length;
        int end = 0;
        int maxPosition = 0; 
        int steps = 0;
        for (int i = 0; i < length - 1; i++) {
            maxPosition = Math.max(maxPosition, i + nums[i]); 
            if (i == end) {
                end = maxPosition;
                steps++;
            }
        }
        return steps;
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/jump-game-ii/solution/tiao-yue-you-xi-ii-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

### 134. 加油站

```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int len = gas.length;
        int[] tank = new int[len];

        tank[0] = gas[0] - cost[0];
        int minIndex = 0;
        int minTank = tank[0];

        if (len == 1) {
            if (tank[0] < 0) { return -1; }
            else { return 0; }
        }
        
        for (int i = 1; i < len; i++) {
            tank[i] = tank[i - 1] + gas[i] - cost[i];
            if (minTank >= tank[i]) {
                minTank = tank[i];
                minIndex = i;
            }
        }

        //minTank >= tank[i]: 有相同的最小值 则取靠后的 （因为答案唯一 所以靠前的minTank=0 无法继续向前行驶）
        //得到的 minIndex 即为 唯一可能 的终点

        //两种情况：1. 终点若为最后一个加油站
        if (minIndex == len - 1) {
            for (int i = 1; i < len - 1; i++) {
                if (tank[i] <= 0) {
                    return -1;
                }
            }
            if (tank[len - 1] < 0) {
                return -1;
            }
            else {
                return 0;
            }
        }
        //2. 如果终点在除了最后一个加油站以外的其他加油站
        else {
            if (tank[len - 1] < 0) {
                return -1;
            }
            for (int i = 0; i < len - 1; i++) {
                if (i != minIndex && i != minIndex + 1 && tank[i] == minTank) {
                    return - 1;
                }
            }
            return minIndex + 1;
        }
    }
}
```

### 135. 分发糖果

```java
class Solution {
    int[] cans;
    int len;
    public int candy(int[] ratings) {
        len = ratings.length;
        cans = new int[len];
        Arrays.fill(cans, 0);
        for (int i = 0; i < len; i++) {
            setCandy(ratings, i);
        }
        int sum = 0;
        for (int v : cans) {
            sum += v;
        }
        return sum;
    }

    public void setCandy(int[] ratings, int index) {
        //该孩子已设置过糖果数 则跳过
        if (cans[index] != 0) { return; }
        int ans = 1;
        
        //比较与左右的评分高低，若比左右高 则先设置左右孩子糖果数
        //与左边比较
        if (index > 0) {
            if (ratings[index] > ratings[index - 1]) {
                setCandy(ratings, index - 1);
                ans = Math.max(cans[index - 1] + 1, ans);
            }
        }
        //与右边比较
        if (index < len - 1) {
            if (ratings[index] > ratings[index + 1]) {
                setCandy(ratings, index + 1);
                ans = Math.max(cans[index + 1] + 1, ans);
            }
        }
        cans[index] = ans;
    }
}
```

### 860. 柠檬水找零

```java
class Solution {
    public boolean lemonadeChange(int[] bills) {
        int m5 = 0;
        int m10 = 0;
        int m20 = 0;
        
        for (int v : bills) {
            // 5
            if (v == 5) {
                m5++;
            }
            // 10
            else if (v == 10) {
                //先给10找零
                if (m5 < 1) {
                    return false;
                }
                else {
                    m5--;
                    m10++;
                }
            }
            // 20
            else {
                //给20找零 (给20找零 5元充足的话可以没有10元 但不能没有5元)
                // 有10元
                if (m10 >= 1) {
                    if (m5 >= 1) {
                        m10--;
                        m5--;
                    }
                    else { return false; }
                }
                //没10元
                else {
                    if (m5 >= 3) {
                        m5 -= 3;
                    }
                    else { return false; }
                }
            }
        }
        return true;
    }
}
```

### 435. 无重叠区间

```java
class Solution {
    //表示该区间是否还未删除
    boolean[] isExist;
    int len;
    //当前删除区间数
    int delCount;
    //最少删除区间数 为该题的返回值
    int minDel;

    boolean[][] lapTable;

    public int eraseOverlapIntervals(int[][] intervals) {
        len = intervals.length;
        isExist = new boolean[len];
        Arrays.fill(isExist, true);
        delCount = 0;
        minDel = len;
        //存储每个区间相互是否重叠
        lapTable = new boolean[len][len];
        for (int i = 0; i < len; i++) {
            for (int j = i; j < len; j++) {
                boolean isLap = isOverlap(intervals, i, j);
                lapTable[i][j] = isLap;
                lapTable[j][i] = isLap;
            }
        }

        dfs(intervals, 0);
        return minDel;
    }

    public void dfs(int[][] intervals, int start) {
        //剪枝
        if (minDel <= delCount + 1) { return; }
        //终止
        if (start == len) {
            boolean hasOverlap = false;
            for (int i = 0; i < len; i++) {
                if (!isExist[i]) { continue; }
                for (int j = i + 1; j < len; j++) {
                    if (j == i || !isExist[j]) { continue; }
                    if (lapTable[i][j]) {
                        hasOverlap = true;
                        break;
                    }
                }
                if (hasOverlap) { break; }
            }

            //回溯终止条件
            if (!hasOverlap) {
                minDel = Math.min(minDel, delCount);
                // System.out.println(Arrays.toString(isExist));
            }
            return;
        }

        //剪枝
        //找出从start索引开始 第一个与其他区间有重叠的索引
        int nextIndex = start;
        boolean isFoundNext = false;
        for (int i = start; i < len; i++) {
            if (!isExist[i]) { continue; }
            for (int j = 0; j < len; j++) {
                if (j == i || !isExist[j]) { continue; }
                if (lapTable[i][j]) {
                    isFoundNext = true;
                    nextIndex = i;
                    break;
                }
            }
            if (isFoundNext) { break; }
        }

        //backtrace body
        if (isFoundNext) {
            isExist[nextIndex] = false;
            delCount++;
            dfs(intervals, nextIndex + 1);
            isExist[nextIndex] = true;
            delCount--;
            dfs(intervals, nextIndex + 1);
        }
    }

    //计算两个区间是否重叠
    public boolean isOverlap(int[][] intervals, int a, int b) {
        if (intervals[a][0] <= intervals[b][0] && intervals[a][1] <= intervals[b][0]) {
            return false;
        }
        if (intervals[a][0] >= intervals[b][1] && intervals[a][1] >= intervals[b][1]) {
            return false;
        }
        return true;
    }
}
```

Compare 排序 Comparator

```java
Arrays.sort(intervals, new Comparator<int[]>() {
    public int compare(int[] intervals1, int[] intervals2) {
        return intervals1[0] - intervals2[0];
    }
});
```

### 763. 划分字母区间

```java
class Solution {
    public List<Integer> partitionLabels(String s) {
        List<Integer> ans = new LinkedList();
        int len = s.length();
        //遍历一遍 s ，将所有字符存入 HashMap， value表示出现次数
        HashMap<Character, Integer> remain = new HashMap();
        for (int i = 0; i < len; i++) {
            remain.put(s.charAt(i), remain.getOrDefault(s.charAt(i), 0) + 1);
        }

        for (int start = 0; start < len; start++) {
            HashSet<Character> curSet = new HashSet();
            int count = 0;
            for (int i = start; i < len; i++) {
                char tmp = s.charAt(i);
                curSet.add(tmp);
                remain.put(tmp, remain.getOrDefault(tmp, 0) - 1);
                count++;
                if (isLastOne(curSet, remain)) {
                    ans.add(count);
                    start = i;
                    break;
                }
            }
        }
        return ans;
    }
    
    //判断剩余集合 remain 中是否还含有当前字母
    public boolean isLastOne(HashSet<Character> curSet, HashMap<Character, Integer> remain) {
        for (Character v : curSet) {
            if (remain.get(v) > 0) {
                return false;
            }
        }
        return true;
    }
}
```

### 56. 合并区间

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        int len = intervals.length;
        Arrays.sort(intervals, new Comparator<int[]>() {
            public int compare(int[] inter1, int[] inter2) {
                return inter1[0] - inter2[0];
            }
        });
        //初始化
        int[][] ans = new int[len][2];
        int ansIndex = 0;
        int left = intervals[0][0];
        int right = intervals[0][1];
        ans[ansIndex][0] = left;
        ans[ansIndex][1] = right;

        //
        for (int i = 1; i < len; i++) {
            //与上一个ans区间无重叠
            if (intervals[i][0] > right) {
                ansIndex++;
                ans[ansIndex][0] = intervals[i][0];
                ans[ansIndex][1] = intervals[i][1];
                left = intervals[i][0];
                right = intervals[i][1];
            }
            //有重叠
            else {
                right = Math.max(right, intervals[i][1]);
                ans[ansIndex][1] = right;
            }
        }
        return Arrays.copyOfRange(ans, 0, ansIndex + 1);
    }
}
```

&nbsp;

---

&nbsp;

## 📡动 态 规 划

* **【TODO】**

&nbsp;

---

&nbsp;

## 🧩图 论

* **【TODO】**

&nbsp;

---

&nbsp;

## 🎯高 级 数 据 结 构

* **【TODO】**
