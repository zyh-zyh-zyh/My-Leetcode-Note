# ğŸ“My LeetCode Note

## ğŸ—ºï¸è·¯çº¿

* [ğŸ”¢æ•°ç»„](#æ•°-ç»„) --> [â›“ï¸é“¾è¡¨](#%EF%B8%8Fé“¾-è¡¨) --> [ğŸ§¾å“ˆå¸Œè¡¨](#å“ˆ-å¸Œ-è¡¨) --> [ğŸ”¡å­—ç¬¦ä¸²](#å­—-ç¬¦-ä¸²) --> [ğŸˆ¯ï¸åŒæŒ‡é’ˆæ³•](#%EF%B8%8FåŒ-æŒ‡-é’ˆ-æ³•)  --> [ğŸ¢æ ˆä¸é˜Ÿåˆ—](#æ ˆ-ä¸-é˜Ÿ-åˆ—) --> [ğŸŒ³æ ‘](#æ ‘) --> [ğŸ”™å›æº¯](#å›-æº¯) --> [ğŸ’¯è´ªå¿ƒ](#è´ª-å¿ƒ) --> [ğŸ“¡åŠ¨æ€è§„åˆ’](#åŠ¨-æ€-è§„-åˆ’) --> [ğŸ§©å›¾è®º](#å›¾-è®º) --> [ğŸ¯é«˜çº§æ•°æ®ç»“æ„](#é«˜-çº§-æ•°-æ®-ç»“-æ„)

æŒ‰é¢˜å‹åˆ·å®Œåï¼Œå†ä»`ç®€å•`åˆ·èµ·ï¼Œåšäº†å‡ ä¸ªç±»å‹é¢˜ç›®ä¹‹åï¼Œå†æ…¢æ…¢åš`ä¸­ç­‰`é¢˜ç›®ã€`å›°éš¾`é¢˜ç›®ã€‚

* è·¯çº¿ fromï¼š[ä»£ç éšæƒ³å½•](https://programmercarl.com/)

* é¢˜è§£è¯­è¨€ï¼š`Java`

&nbsp;

---
&nbsp;

## ğŸ”¢æ•° ç»„

### 27. ç§»é™¤å…ƒç´ 

* **ã€TODOã€‘**

### 26. åˆ é™¤æ’åºæ•°ç»„ä¸­çš„é‡å¤é¡¹

* **ã€TODOã€‘**

### 283. ç§»åŠ¨é›¶

* **ã€TODOã€‘**

### [844. æ¯”è¾ƒå«é€€æ ¼çš„å­—ç¬¦ä¸²](./Solutions/844.æ¯”è¾ƒå«é€€æ ¼çš„å­—ç¬¦ä¸².md)

### [977. æœ‰åºæ•°ç»„çš„å¹³æ–¹](./Solutions/977.æœ‰åºæ•°ç»„çš„å¹³æ–¹.md)

### [209. é•¿åº¦æœ€å°çš„å­æ•°ç»„](./Solutions/209.é•¿åº¦æœ€å°çš„å­æ•°ç»„.md)

### [904. æ°´æœæˆç¯®](./Solutions/904.æ°´æœæˆç¯®.md)

### [76. æœ€å°è¦†ç›–å­ä¸²](./Solutions/76.æœ€å°è¦†ç›–å­ä¸².md)

### [59. èºæ—‹çŸ©é˜µ II](./Solutions/59.èºæ—‹çŸ©é˜µII.md)

&nbsp;

---

&nbsp;

## â›“ï¸é“¾ è¡¨

### [203. ç§»é™¤é“¾è¡¨å…ƒç´ ](./Solutions/203.ç§»é™¤é“¾è¡¨å…ƒç´ .md)

### [707. è®¾è®¡é“¾è¡¨](./Solutions/707.è®¾è®¡é“¾è¡¨.md)

### [206. åè½¬é“¾è¡¨](./Solutions/206.åè½¬é“¾è¡¨.md)

### [24. ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹](./Solutions/24.ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹.md)

### [19. åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬ N ä¸ªç»“ç‚¹](./Solutions/19.åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬Nä¸ªç»“ç‚¹.md)

### [é¢è¯•é¢˜ 02.07. é“¾è¡¨ç›¸äº¤](./Solutions/é¢è¯•é¢˜02.07.é“¾è¡¨ç›¸äº¤.md)

### [142. ç¯å½¢é“¾è¡¨II](./Solutions/142.ç¯å½¢é“¾è¡¨II.md)

&nbsp;

---

&nbsp;

## ğŸ§¾å“ˆ å¸Œ è¡¨

### åŸºç¡€ï¼š

**å½“æˆ‘ä»¬é‡åˆ°äº†è¦å¿«é€Ÿåˆ¤æ–­ä¸€ä¸ªå…ƒç´ æ˜¯å¦å‡ºç°é›†åˆé‡Œçš„æ—¶å€™ï¼Œå°±è¦è€ƒè™‘å“ˆå¸Œæ³•**ã€‚

ä½†æ˜¯å“ˆå¸Œæ³•ä¹Ÿæ˜¯**ç‰ºç‰²äº†ç©ºé—´æ¢å–äº†æ—¶é—´**ï¼Œå› ä¸ºæˆ‘ä»¬è¦ä½¿ç”¨é¢å¤–çš„æ•°ç»„ï¼Œsetæˆ–è€…æ˜¯mapæ¥å­˜æ”¾æ•°æ®ï¼Œæ‰èƒ½å®ç°å¿«é€Ÿçš„æŸ¥æ‰¾ã€‚

å¦‚æœåœ¨åšé¢è¯•é¢˜ç›®çš„æ—¶å€™é‡åˆ°éœ€è¦åˆ¤æ–­ä¸€ä¸ªå…ƒç´ æ˜¯å¦å‡ºç°è¿‡çš„åœºæ™¯ä¹Ÿåº”è¯¥ç¬¬ä¸€æ—¶é—´æƒ³åˆ°å“ˆå¸Œæ³•ï¼

[( from ä»£ç éšæƒ³å½• å“ˆå¸Œè¡¨ç†è®ºåŸºç¡€ )](https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%89%E7%A7%8D%E5%93%88%E5%B8%8C%E7%BB%93%E6%9E%84)

&nbsp;

### [242. æœ‰æ•ˆçš„å­—æ¯å¼‚ä½è¯](./Solutions/242.æœ‰æ•ˆçš„å­—æ¯å¼‚ä½è¯.md)

### [383. èµé‡‘ä¿¡](./Solutions/383.èµé‡‘ä¿¡.md)

### [49. å­—æ¯å¼‚ä½è¯åˆ†ç»„](./Solutions/49.å­—æ¯å¼‚ä½è¯åˆ†ç»„.md)

### [438. æ‰¾åˆ°å­—ç¬¦ä¸²ä¸­æ‰€æœ‰å­—æ¯å¼‚ä½è¯](./Solutions/438.æ‰¾åˆ°å­—ç¬¦ä¸²ä¸­æ‰€æœ‰å­—æ¯å¼‚ä½è¯.md)

### [349. ä¸¤ä¸ªæ•°ç»„çš„äº¤é›†](./Solutions/350.ä¸¤ä¸ªæ•°ç»„çš„äº¤é›†II.md)

### [202. å¿«ä¹æ•°](./Solutions/202.å¿«ä¹æ•°.md)

### 1. ä¸¤æ•°ä¹‹å’Œ

* **ã€TODOã€‘**

### [454. å››æ•°ç›¸åŠ II](./Solutions/454.å››æ•°ç›¸åŠ II.md)

### [15. ä¸‰æ•°ä¹‹å’Œ](./Solutions/15.ä¸‰æ•°ä¹‹å’Œ.md)

### 18. å››æ•°ä¹‹å’Œ

* **ã€TODOã€‘**

&nbsp;

---

&nbsp;

## ğŸ”¡å­— ç¬¦ ä¸²

### 344. åè½¬å­—ç¬¦ä¸²

* **ã€TODOã€‘**

### [541. åè½¬å­—ç¬¦ä¸²II](./Solutions/541.åè½¬å­—ç¬¦ä¸²II.md)

### [å‰‘æŒ‡Offer 05. æ›¿æ¢ç©ºæ ¼](./Solutions/å‰‘æŒ‡Offer05.æ›¿æ¢ç©ºæ ¼.md)

### [151. ç¿»è½¬å­—ç¬¦ä¸²é‡Œçš„å•è¯](./Solutions/151.ç¿»è½¬å­—ç¬¦ä¸²é‡Œçš„å•è¯.md)

### [å‰‘æŒ‡Offer58-II. å·¦æ—‹è½¬å­—ç¬¦ä¸²](./Solutions/å‰‘æŒ‡Offer58-II.å·¦æ—‹è½¬å­—ç¬¦ä¸².md)

### [28. å®ç° strStr()](./Solutions/28.å®ç°strStr().md)

### [459. é‡å¤çš„å­å­—ç¬¦ä¸²](./Solutions/459.é‡å¤çš„å­å­—ç¬¦ä¸².md)

&nbsp;

---

&nbsp;

## ğŸˆ¯ï¸åŒ æŒ‡ é’ˆ æ³•

### [27. ç§»é™¤å…ƒç´ ](./Solutions/27.ç§»é™¤å…ƒç´ .md)

### [344. åè½¬å­—ç¬¦ä¸²](./Solutions/344.åè½¬å­—ç¬¦ä¸².md)

### 151.ç¿»è½¬å­—ç¬¦ä¸²é‡Œçš„å•è¯

### 206.åè½¬é“¾è¡¨

### 19.åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬Nä¸ªèŠ‚ç‚¹

### é¢è¯•é¢˜ 02.07. é“¾è¡¨ç›¸äº¤

### 142.ç¯å½¢é“¾è¡¨II

### 15. ä¸‰æ•°ä¹‹å’Œ

### 18. å››æ•°ä¹‹å’Œ

&nbsp;

---

&nbsp;


## ğŸ¢æ ˆ ä¸ é˜Ÿ åˆ—

### [232. ç”¨æ ˆå®ç°é˜Ÿåˆ—](./Solutions/232.ç”¨æ ˆå®ç°é˜Ÿåˆ—.md)

### [225. ç”¨é˜Ÿåˆ—å®ç°æ ˆ](./Solutions/225.ç”¨é˜Ÿåˆ—å®ç°æ ˆ.md)

### [20. æœ‰æ•ˆçš„æ‹¬å·](./Solutions/20.æœ‰æ•ˆçš„æ‹¬å·.md)

### [1047. åˆ é™¤å­—ç¬¦ä¸²ä¸­çš„æ‰€æœ‰ç›¸é‚»é‡å¤é¡¹](./Solutions/1047.åˆ é™¤å­—ç¬¦ä¸²ä¸­çš„æ‰€æœ‰ç›¸é‚»é‡å¤é¡¹.md)

### [150. é€†æ³¢å…°è¡¨è¾¾å¼æ±‚å€¼](./Solutions/150.é€†æ³¢å…°è¡¨è¾¾å¼æ±‚å€¼.md)

### [239. æ»‘åŠ¨çª—å£æœ€å¤§å€¼](./Solutions/239.æ»‘åŠ¨çª—å£æœ€å¤§å€¼.md)

### [347. å‰Kä¸ªé«˜é¢‘å…ƒç´ ](./Solutions/347.å‰Kä¸ªé«˜é¢‘å…ƒç´ .md)

### æ ˆä¸é˜Ÿåˆ—æ€»ç»“



* **ã€TODOã€‘**

&nbsp;

---

&nbsp;

## ğŸŒ³æ ‘

### [144. äºŒå‰æ ‘çš„å‰åºéå†](./Solutions/144.äºŒå‰æ ‘çš„å‰åºéå†.md)

### [145. äºŒå‰æ ‘çš„ååºéå†](./Solutions/145.äºŒå‰æ ‘çš„ååºéå†.md)

### [94. äºŒå‰æ ‘çš„ä¸­åºéå†](./Solutions/94.äºŒå‰æ ‘çš„ä¸­åºéå†.md)

### [102. äºŒå‰æ ‘çš„å±‚åºéå†](./Solutions/102.äºŒå‰æ ‘çš„å±‚åºéå†.md)

### [226. ç¿»è½¬äºŒå‰æ ‘](./Solutions/226.ç¿»è½¬äºŒå‰æ ‘.md)

### [101. å¯¹ç§°äºŒå‰æ ‘](./Solutions/101.å¯¹ç§°äºŒå‰æ ‘.md)

### [104. äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦](./Solutions/104.äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦.md)

### 559. nå‰æ ‘çš„æœ€å¤§æ·±åº¦

### [111. äºŒå‰æ ‘çš„æœ€å°æ·±åº¦](./Solutions/111.äºŒå‰æ ‘çš„æœ€å°æ·±åº¦.md)

### [222. å®Œå…¨äºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°](./Solutions/222.å®Œå…¨äºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°.md)

### [110. å¹³è¡¡äºŒå‰æ ‘](./Solutions/110.å¹³è¡¡äºŒå‰æ ‘.md)

### [257. äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„](./Solutions/257.äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„.md)

### [404. å·¦å¶å­ä¹‹å’Œ](./Solutions/404.å·¦å¶å­ä¹‹å’Œ.md)

### [513. æ‰¾æ ‘å·¦ä¸‹è§’çš„å€¼](./Solutions/513.æ‰¾æ ‘å·¦ä¸‹è§’çš„å€¼.md)

### [112. è·¯å¾„æ€»å’Œ](./Solutions/112.è·¯å¾„æ€»å’Œ.md)

### 106. ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘

### [654. æœ€å¤§äºŒå‰æ ‘](./Solutions/654.æœ€å¤§äºŒå‰æ ‘.md)

### [617. åˆå¹¶äºŒå‰æ ‘](./Solutions/617.åˆå¹¶äºŒå‰æ ‘.md)

### 700. äºŒå‰æœç´¢æ ‘ä¸­çš„æœç´¢

```java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        if (root == null) return null;
        Queue<TreeNode> que = new LinkedList();
        que.add(root);
        while (!que.isEmpty()) {
            TreeNode cur = que.remove();
            if (cur.val == val) return cur;
            if (cur.left != null) que.add(cur.left);
            if (cur.right != null) que.add(cur.right);
        }
        return null;
    }
}
```

### 98. éªŒè¯äºŒå‰æœç´¢æ ‘

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        if (root == null) return true;
        LinkedList<Integer> log = new LinkedList();
        midTra(root, log);
        if (log.size() < 1) return true;
        for (int i = 1; i < log.size(); i++) {
            if (log.get(i) <= log.get(i - 1)) return false;
        }
        return true;
    }

    public void midTra(TreeNode root, LinkedList log) {
        if (root == null) return ;
        midTra(root.left, log);
        log.add(root.val);
        midTra(root.right, log);
    }
}
```

### 530. äºŒå‰æœç´¢æ ‘çš„æœ€å°ç»å¯¹å·®

```java
class Solution {
    LinkedList<Integer> log = new LinkedList();
    public int getMinimumDifference(TreeNode root) {
        long min = Long.MAX_VALUE;
        inorder(root);
        for (int i = 1; i < log.size(); i++) {
            long value = log.get(i) - log.get(i - 1);
            if (value < 0) value = -value;
            if (value < min) min = value;
        }
        return (int)min;
    }

    public void inorder(TreeNode root) {
        if (root == null) return;
        inorder(root.left);
        log.add(root.val);
        inorder(root.right);
    }
}
```

### 501. äºŒå‰æœç´¢æ ‘ä¸­çš„ä¼—æ•°

```java
class Solution {
    TreeNode pre = null;
    HashMap<Integer, Integer> freq = new HashMap();
    public int[] findMode(TreeNode root) {
        inorder(root);
        int max = 0;
        for (int k : freq.keySet()) {
            int fre = freq.get(k);
            if (fre > max) {
                max = fre;
            }
        }
        int[] ans = new int[freq.size()];
        int index = 0;
        for (int k : freq.keySet()) {
            int fre = freq.get(k);
            if (fre == max) {
                ans[index++] = k;
            }
        }
        return Arrays.copyOfRange(ans, 0, index);
    }

    public void inorder(TreeNode root) {
        if (root == null) return;
        inorder(root.left);
        freq.put(root.val, freq.getOrDefault(root.val, 0) + 1);
        inorder(root.right);
    }
}
```

### 236. äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    TreeNode pub;
    boolean foundFirst = false;
    boolean isDone = false;
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        order(root, p, q);
        return pub;
    }

    public void order(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null) return;

        //ä¸­åºæœç´¢ å·¦å­èŠ‚ç‚¹é€’å½’
        if (!isDone) order(root.left, p, q);

        if (!isDone) {
            //æœªæœç´¢åˆ°ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ ä¸­åºéå†
            if (!foundFirst) {
                //æœç´¢ç¬¬ä¸€ä¸ªèŠ‚ç‚¹
                if (root.val == p.val || root.val == q.val) {
                    foundFirst = true;
                    pub = root;
                    if (root.left == null && root.right == null) {
                    //æ˜¯å¶å­ç»“ç‚¹ ç›´æ¥ç»“æŸé€’å½’

                    return;
                    }
                }
            }
            //å·²æ‰¾åˆ°ç¬¬ä¸€ä¸ªèŠ‚ç‚¹
            else {
                if (isFather(pub, root)) {
                    pub = root;
                }
                if (root.val == p.val || root.val == q.val) {
                    //å·²ç»æœç´¢åˆ°ç¬¬äºŒä¸ªèŠ‚ç‚¹ æ ‡è®°flag isDone ç»“æŸä¹‹åçš„æ‰€æœ‰é€’å½’
                    isDone = true;
                    return;
                }
            }
        }
        //å³å­èŠ‚ç‚¹ä¸­åºéå†é€’å½’
        if (!isDone) order(root.right, p, q);
    }

    //åˆ¤æ–­ son æ˜¯å¦åœ¨ father çš„å­æ ‘ä¸­
    public boolean isFather(TreeNode son, TreeNode father) {
        if (father == null || son == null) { return false; }
        if (father.left != null && father.left.val == son.val) { return true; }
        if (father.right != null && father.right.val == son.val) { return true; }
        return isFather(son, father.left) || isFather(son, father.right);
    }
}
```
* Solution 2

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */

class Solution {
    TreeNode ans = null;
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        tra(root, p, q);
        return ans;
    }

    public boolean tra(TreeNode cur, TreeNode p, TreeNode q) {
        if (cur == null) return false;
        boolean lhave = tra(cur.left, p, q);
        boolean rhave = tra(cur.right, p, q);
        //å·¦å³å„ä¸€ä¸ªèŠ‚ç‚¹ åˆ™è¯¥èŠ‚ç‚¹ä¸ºç›®æ ‡èŠ‚ç‚¹
        if (lhave && rhave) { ans = cur; }
        //å½“å‰èŠ‚ç‚¹ä¸ºä¸€ä¸ªï¼Œå­æ ‘å«ä¸€ä¸ªï¼Œåˆ™è¯¥èŠ‚ç‚¹ä¸ºç›®æ ‡èŠ‚ç‚¹
        if ((cur == p) || (cur == q) && (lhave || rhave)) { ans = cur; }
        return lhave || rhave || (cur == p) || (cur == q);
    }
}
```

### 235. äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

```java

```

### 701.äºŒå‰æœç´¢æ ‘ä¸­çš„æ’å…¥æ“ä½œ

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if (root == null) { return new TreeNode(val); }
        TreeNode tar = new TreeNode(val);
        locate(root, tar);
        return root;
    }

    public void locate(TreeNode root, TreeNode tar) {
        TreeNode cur = root;
        if (tar.val < cur.val) {
            if (cur.left != null) {
                locate(cur.left, tar);
            }
            else {
                cur.left = tar;
            }
        }
        else if (tar.val > cur.val) {
            if (cur.right != null) {
                locate(cur.right, tar);
            }
            else {
                cur.right = tar;
            }
        }
    }
}
```

### 450.åˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­çš„èŠ‚ç‚¹

```java
æ­¤é¢˜å’Œ669 é‡ç‚¹åœ¨æ¯æ¬¡é€’å½’çš„è¿”å›å€¼ æ˜¯è¯¥èŠ‚ç‚¹æœ¬èº«ï¼ˆæ¶‰åŠåˆ é™¤è¯¥èŠ‚ç‚¹ åˆ™è‹¥éœ€è¦åˆ é™¤ å°±è¿”å›åˆ é™¤åçš„æ›¿ä»£èŠ‚ç‚¹ï¼‰

```java
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        if (root == null) return null;

        if (root.val == key) {
            // æƒ…å†µ1ã€2ï¼šè¢«åˆ é™¤èŠ‚ç‚¹æ²¡æœ‰å­èŠ‚ç‚¹ã€æ²¡æœ‰å·¦å­æ ‘ã€æ²¡æœ‰å³å­æ ‘
            if (root.left == null) return root.right;
            if (root.right == null) return root.left;
            // æƒ…å†µ3ï¼šè¢«åˆ é™¤èŠ‚ç‚¹æ—¢æœ‰å·¦å­æ ‘ï¼Œåˆæœ‰å³å­æ ‘ï¼šå–å³å­æ ‘çš„æœ€å°èŠ‚ç‚¹å–ä»£è¢«åˆ é™¤èŠ‚ç‚¹ï¼Œå¹¶åˆ é™¤å³å­æ ‘çš„æœ€å°èŠ‚ç‚¹
            TreeNode minNodeOfRight = findMinNode(root.right);
            root.val = minNodeOfRight.val;
            root.right = deleteNode(root.right, minNodeOfRight.val);
        } else if (root.val < key) {
            root.right = deleteNode(root.right, key);
        } else if (root.val > key) {
            root.left = deleteNode(root.left, key);
        }

        return root;
    }

    private TreeNode findMinNode(TreeNode node) {
        while (node.left != null) {
            node = node.left;
        }
        return node;
    }
}

ä½œè€…ï¼šar-lai
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/delete-node-in-a-bst/solution/javachao-jian-dan-de-er-fen-sou-suo-di-g-z83v/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

* ä»¿å†™

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode deleteNode(TreeNode cur, int key) {
        if (cur == null) return null;

        if (cur.val == key) {
            //cur åªæœ‰å•å­èŠ‚ç‚¹æˆ–æ— å­èŠ‚ç‚¹
            if (cur.left == null) return cur.right;
            if (cur.right == null) return cur.left;

            //å«æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹
            TreeNode maxOfLeft = cur.left;
            while (maxOfLeft.right != null) {
                maxOfLeft = maxOfLeft.right;
            }
            cur.val = maxOfLeft.val;
            cur.left = deleteNode(cur.left, maxOfLeft.val);
        }
        else if (cur.val < key) {
            cur.right = deleteNode(cur.right, key);
        }
        else if (cur.val > key) {
            cur.left = deleteNode(cur.left, key);
        }
        return cur;
    }
}
```

### 669. ä¿®å‰ªäºŒå‰æœç´¢æ ‘

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode trimBST(TreeNode root, int low, int high) {
        if (root == null) return null;
        int value = root.val;
        if (value < low) {
            root = trimBST(root.right, low, high);
        }
        else if (value > high) {
            root = trimBST(root.left, low, high);
        }
        else {
            root.left = trimBST(root.left, low, high);
            root.right = trimBST(root.right, low, high);
        }
        return root;
    }
}
```

### 108.å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        TreeNode start = new TreeNode();
        make(nums, start, 0, nums.length - 1);
        return start;
    }

    public void make(int[] nums, TreeNode cur, int low, int high) {
        int mid = (high + low) / 2;
        if (low > high) { return; }

        cur.val = nums[mid];
        if (low == high) { return; }

        if (high - low == 1) {
            cur.right = new TreeNode(); 
            make(nums, cur.right, high, high);
            return;
        }
		//high - low > 1:
        cur.left = new TreeNode(); 
        cur.right = new TreeNode(); 

        make(nums, cur.left, low, mid - 1);
        make(nums, cur.right, mid + 1, high);
    }
}
```

### 538.æŠŠäºŒå‰æœç´¢æ ‘è½¬æ¢ä¸ºç´¯åŠ æ ‘

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int sum = 0;
    // right - root - left
    public TreeNode convertBST(TreeNode root) {
        if (root == null) return null;
        //right
        convertBST(root.right);
        //root
        sum += root.val;
        root.val = sum;

        //left
        convertBST(root.left);
        return root;
    }
}
```

&nbsp;

---

&nbsp;

## ğŸ”™å› æº¯

&nbsp;

### 77. ç»„åˆ

```java
class Solution {
    LinkedList<Integer> base = new LinkedList();
    List<List<Integer>> ans = new ArrayList();
    public List<List<Integer>> combine(int n, int k) {
        comb(n, k, 1);
        return ans;
    }

    public void comb(int n, int k, int start) {
        if (base.size() == k) {
            ans.add(new ArrayList(base));
            return;
        }

        for (int i = start; i <= n; i++) {
            base.add(i);
            comb(n, k, i + 1);
            base.removeLast();
        }
    }
}
```



### 216. ç»„åˆæ€»å’Œ III

```java
class Solution {
    LinkedList<Integer> base = new LinkedList();
    ArrayList<List<Integer>> ans = new ArrayList();
    int sum;
    public List<List<Integer>> combinationSum3(int k, int n) {
        comb(k, n, 1);
        return ans;
    }

    public void comb(int k, int n, int start) {
        // end condition: æ»¡è¶³æ¡ä»¶
        if (sum == n && base.size() == k) {
            ans.add(new ArrayList(base));
            return;
        }
        //end condition: æ— æ³•æ»¡è¶³æ¡ä»¶
        if (sum > n || base.size() >= k) {
            return;
        }

        //å¾ªç¯ä½“
        for (int i = start; i < 10; i++) {
            base.add(i);
            sum += i;
            comb(k, n, i + 1);
            base.removeLast();
            sum -= i;
        }
    }
}
```

### 17. ç”µè¯å·ç çš„å­—æ¯ç»„åˆ

```java
class Solution {
    ArrayList<String> ans = new ArrayList();
    StringBuilder base = new StringBuilder();
    String[] dic = new String[10];
    public List<String> letterCombinations(String digits) {
        dic[2] = "abc";
        dic[3] = "def";
        dic[4] = "ghi";
        dic[5] = "jkl";
        dic[6] = "mno";
        dic[7] = "pqrs";
        dic[8] = "tuv";
        dic[9] = "wxyz";
        combNumber(digits, 0);
        return ans;
    }

    public void combNumber(String digits, int indexOfDigits) {
        //end condition
        if (indexOfDigits >= digits.length()) {
            //é˜²æ­¢æ·»åŠ ç©ºçš„ String è¿› ans,å¯¼è‡´ç»“æœä¸º: [""] è€Œä¸æ˜¯: []
            if (base.length() > 0) {
                ans.add(base.toString());
            }
            return;
        }

        //backtracking body
        int callNumber = digits.charAt(indexOfDigits) - 48;
        for (int i = 0; i < dic[callNumber].length(); i++) {
            base.append(dic[callNumber].charAt(i));
            combNumber(digits, indexOfDigits + 1);
            //back
            base.deleteCharAt(base.length() - 1);
        }
    }
}
```

### 39. ç»„åˆæ€»å’Œ

```java
class Solution {
    ArrayList<List<Integer>> ans = new ArrayList();
    LinkedList<Integer> base = new LinkedList();

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        comb(candidates, target, 0, 0);
        return ans;
    }

    public void comb(int[] candidates, int target, int sum, int index) {
        //end condition
        if (sum == target) {
            ans.add(new ArrayList(base));
            return;
        }
        else if (sum > target || index >= candidates.length) {
            return;
        }

        //backTracking body
            
        sum += candidates[index];
        base.add(candidates[index]);
        comb(candidates, target, sum, index);
        
        base.removeLast();
        sum -= candidates[index];

        comb(candidates, target, sum, index + 1);
    }
}
```

### 40. ç»„åˆæ€»å’ŒII

åŸºç¡€ç‰ˆ è¶…æ—¶ï¼š

```java
class Solution {
    LinkedList<Integer> base = new LinkedList();
    ArrayList<List<Integer>> ans = new ArrayList();
    HashSet<List<Integer>> set = new HashSet();

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        comb(candidates, target, 0, 0);
        for (List<Integer> tmp : set) {
            ans.add(tmp);
        }
        return ans;
    }

    public void comb(int[] candidates, int target, int sum, int start) {
        //end condition
        if (sum == target) {
            ArrayList<Integer> tmp = new ArrayList(base);
            tmp.sort(Comparator.naturalOrder());
            if (!set.contains(tmp)) {
                set.add(tmp);
            }
            return;
        }
        else if (sum >= target) {
            return;
        }

        //backTracking
        for (int i = start; i < candidates.length; i++) {
            sum += candidates[i];
            base.add(candidates[i]);
            comb(candidates, target, sum, i + 1);
            sum -= candidates[i];
            base.removeLast();
        }
    }
}
```

* æ”¹è¿›

```java
class Solution {
    LinkedList<Integer> base = new LinkedList();
    ArrayList<List<Integer>> ans = new ArrayList();

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        comb(candidates, target, 0, 0);
        return ans;
    }

    public void comb(int[] candidates, int target, int sum, int start) {
        boolean isBigger = false;
        int last = 0;
        int valueOfLast = 0;
        //end condition
        if (sum == target) {
            ArrayList<Integer> tmp = new ArrayList(base);
            ans.add(tmp);

            isBigger = true;
            return;
        }
        else if (sum > target) {
            isBigger = true;
            return;
        }

        //backTracking
        for (int i = start; i < candidates.length; i++) {
            if (i == start) {
                last = start;
                valueOfLast = candidates[last];
            }
            else if (candidates[i] == valueOfLast) { continue; }
            last = i;
            valueOfLast = candidates[last];
            sum += candidates[i];
            base.add(candidates[i]);
            comb(candidates, target, sum, i + 1);
            sum -= candidates[i];
            base.removeLast();
        }
    }
}
```

### 131. åˆ†å‰²å›æ–‡ä¸²

```java
class Solution {
    LinkedList<String> base = new LinkedList();
    ArrayList<List<String>> ans = new ArrayList();

    public List<List<String>> partition(String s) {
        backtrace(s, 0);
        return ans;

    }

    public void backtrace(String s, int start) {
        //end condition
        if (start == s.length()) {
            ans.add(new ArrayList(base));
            return;
        }

        //back trace body
        for (int i = start; i < s.length(); i++) {
            String sub = s.substring(start, i + 1);
            if (isPalindrome(sub)) {
                base.add(sub);
                backtrace(s, i + 1);
                base.removeLast();
            }
        }
    }

    public boolean isPalindrome(String s) {
        int len = s.length();
        if (len == 1) { return true; }
        int left = 0;
        int right = len - 1;
        while (left < right) {
            if (s.charAt(left++) != s.charAt(right--)) { return false; }
        }
        return true;
    }
}
```

### 93. å¤åŸIPåœ°å€

```java
class Solution {
    LinkedList<String> base = new LinkedList();
    ArrayList<String> ans = new ArrayList();

    public List<String> restoreIpAddresses(String s) {
        backtrace(s, 0);
        return ans;
    }

    public void backtrace(String s, int start) {
        //end condition
        if (start == s.length() && base.size() == 4) {
            ans.add(concateIP(base));
            return;
        }
        // ä¸¤ç§æ¡ä»¶é€€å‡ºï¼š1. å·²éå†å®Œ s ä½†æœªå‡‘å¤Ÿ4æ®µipï¼› 2. å·²å‡‘å¤Ÿ4æ®µipä½†sæœªéå†å®Œ
        else if(start == s.length() ^ base.size() == 4) { return; }

        //backtrace body
        for (int i = start; i < s.length(); i++) {
            if (i - start == 3) { break; }
            String tmp = s.substring(start, i + 1);
            int num = isIP(tmp);
            if (num != -1) {
                base.add(tmp);
                backtrace(s, i + 1);
                base.removeLast();
            }
        }
    }

    //åˆ¤æ–­æ‰€æˆªå‡ºçš„ String æ˜¯å¦ä¸ºåˆæ³•IPï¼Œä¸åˆæ³•åˆ™è¿”å› -1ï¼› åˆæ³•åˆ™è¿”å›å¯¹åº” int å€¼
    public int isIP(String s) {
        if (s.length() < 1) { return -1; }
        int num = Integer.valueOf(s);
        if (s.charAt(0) == '0' && s.length() > 1) { return -1; }
        if (num < 0 || num > 255) { return -1; }
        return num;
    }

    //ç”¨ä¿å­˜4æ®µIP String çš„ List æ‹¼æ¥å‡ºIP String
    public String concateIP(LinkedList<String> base) {
        StringBuilder sb = new StringBuilder();
        for (String s : base) {
            sb.append(s);
            sb.append('.');
        }
        sb.deleteCharAt(sb.length() - 1);
        return sb.toString();
    }
}
```

### 78. å­é›†é—®é¢˜

* å»é‡é—®é¢˜ å…¨é›†å¦‚ä½•æ·»åŠ 

```java
class Solution {
    LinkedList<Integer> base = new LinkedList();
    ArrayList<List<Integer>> ans = new ArrayList();
    public List<List<Integer>> subsets(int[] nums) {
        ans.add(new ArrayList());
        if (nums.length == 0) {
            return ans;
        }
        List<Integer> allnums = Arrays.asList(nums);
        ans.add(allnums);
        if (nums.length == 0) {
            return ans;
        }
        backtrace(nums, 0);
        return ans;
    }

    public void backtrace(int[] nums, int start) {
        //end condition
        if (base.size() == nums.length) {
            return;
        }

        //backtrace body
        for (int i = start; i < nums.length; i++) {
            base.add(nums[i]);
            ans.add(new ArrayList(base));
            backtrace(nums, i + 1);
            base.removeLast();
        }
    }
}
```

* HashSet å»é‡

```java
class Solution {
    LinkedList<Integer> base = new LinkedList();
    ArrayList<List<Integer>> ans = new ArrayList();
    HashSet<List<Integer>> set = new HashSet();
    public List<List<Integer>> subsets(int[] nums) {
        ans.add(new ArrayList());
        set.add(new ArrayList());
        if (nums.length == 0) {
            return ans;
        }

        backtrace(nums, 0);
        return ans;
    }

    public void backtrace(int[] nums, int start) {
        //end condition
        if (base.size() == nums.length) {
            return;
        }

        //backtrace body
        for (int i = start; i < nums.length; i++) {
            base.add(nums[i]);
            if (!set.contains(base)) {
                ans.add(new ArrayList(base));
                set.add(new ArrayList(base));
            }
            backtrace(nums, i + 1);
            base.removeLast();
        }
    }
}
```

### 90. å­é›†II

```java
class Solution {
    LinkedList<Integer> base = new LinkedList();
    ArrayList<List<Integer>> ans = new ArrayList();
    HashSet<List<Integer>> set = new HashSet();
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        ans.add(new ArrayList());
        set.add(new ArrayList());
        if (nums.length == 0) {
            return ans;
        }
        Arrays.sort(nums);

        backtrace(nums, 0);
        return ans;
    }

    public void backtrace(int[] nums, int start) {
        //end condition
        if (base.size() == nums.length) {
            return;
        }

        //backtrace body
        for (int i = start; i < nums.length; i++) {
            base.add(nums[i]);
            if (!set.contains(base)) {
                ans.add(new ArrayList(base));
                set.add(new ArrayList(base));
            }
            backtrace(nums, i + 1);
            base.removeLast();
        }

    }
}
```

### 491. é€’å¢å­åºåˆ—

```java
class Solution {
    ArrayList<List<Integer>> ans = new ArrayList();
    LinkedList<Integer> base = new LinkedList();
    HashSet<List<Integer>> set = new HashSet();
    public List<List<Integer>> findSubsequences(int[] nums) {
        for (int i = 0; i < nums.length - 1; i++) {
            backtrace(nums, i, i);
        }
        return ans;
    }

    public void backtrace(int[] nums, int start, int cur) {
        //end condition
        if (cur >= nums.length) {
            return;
        }
        //backtrace body
        //ç¬¬ä¸€ä½è¾“å…¥
        if (start == cur) {
            base.add(nums[cur]);
            backtrace(nums, start, cur + 1);
            base.removeLast();
        }
        else if ((nums[cur] >= base.peekLast())) {
            base.add(nums[cur]);
            if (!set.contains(base)) {
                set.add(new ArrayList(base));
                ans.add(new ArrayList(base));
            }
            backtrace(nums, start, cur + 1);
            base.removeLast();
        }
        if (start != cur) {
            backtrace(nums, start, cur + 1);
        }
    }
}
```

* å»é‡æ€è·¯ï¼š

> é‚£å¦‚ä½•ä¿è¯æ²¡æœ‰é‡å¤å‘¢ï¼Ÿæˆ‘ä»¬éœ€è¦ç»™ã€Œä¸é€‰æ‹©ã€åšä¸€ä¸ªé™å®šæ¡ä»¶ï¼Œåªæœ‰å½“**å½“å‰çš„å…ƒç´ ä¸ç­‰äºä¸Šä¸€ä¸ªé€‰æ‹©çš„å…ƒç´ **çš„æ—¶å€™ï¼Œæ‰è€ƒè™‘ä¸é€‰æ‹©å½“å‰å…ƒç´ ï¼Œç›´æ¥é€’å½’åé¢çš„å…ƒç´ ã€‚å› ä¸ºå¦‚æœæœ‰ä¸¤ä¸ªç›¸åŒçš„å…ƒç´ ï¼Œæˆ‘ä»¬ä¼šè€ƒè™‘è¿™æ ·å››ç§æƒ…å†µï¼š
>
> 1.å‰è€…è¢«é€‰æ‹©ï¼Œåè€…è¢«é€‰æ‹©
> **2.å‰è€…è¢«é€‰æ‹©ï¼Œåè€…ä¸è¢«é€‰æ‹©**
> **3.å‰è€…ä¸è¢«é€‰æ‹©ï¼Œåè€…è¢«é€‰æ‹©**
> 4.å‰è€…ä¸è¢«é€‰æ‹©ï¼Œåè€…ä¸è¢«é€‰æ‹©
> å…¶ä¸­ç¬¬äºŒç§æƒ…å†µå’Œç¬¬ä¸‰ç§æƒ…å†µå…¶å®æ˜¯ç­‰ä»·çš„ï¼Œæˆ‘ä»¬è¿™æ ·é™åˆ¶ä¹‹åï¼Œ**èˆå¼ƒäº†ç¬¬äºŒç§ï¼Œä¿ç•™äº†ç¬¬ä¸‰ç§**ï¼Œäºæ˜¯è¾¾åˆ°äº†å»é‡çš„ç›®çš„ã€‚
>
> ä½œè€…ï¼šLeetCode-Solution
> é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/increasing-subsequences/solution/di-zeng-zi-xu-lie-by-leetcode-solution/
> æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
> è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚



```java
class Solution {
    List<Integer> temp = new ArrayList<Integer>();
    List<List<Integer>> ans = new ArrayList<List<Integer>>();

    public List<List<Integer>> findSubsequences(int[] nums) {
        dfs(0, Integer.MIN_VALUE, nums);
        return ans;
    }

    public void dfs(int cur, int last, int[] nums) {
        if (cur == nums.length) {
            if (temp.size() >= 2) {
                ans.add(new ArrayList<Integer>(temp));
            }
            return;
        }
        if (nums[cur] >= last) {
            temp.add(nums[cur]);
            dfs(cur + 1, nums[cur], nums);
            temp.remove(temp.size() - 1);
        }
        if (nums[cur] != last) {
            dfs(cur + 1, last, nums);
        }
    }
}

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/increasing-subsequences/solution/di-zeng-zi-xu-lie-by-leetcode-solution/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

### 46. å…¨æ’åˆ—

```java
class Solution {
    LinkedList<Integer> base = new LinkedList();
    ArrayList<List<Integer>> ans = new ArrayList();
    HashSet<Integer> set = new HashSet();
    public List<List<Integer>> permute(int[] nums) {
        dfs(nums, 0);
        return ans;
    }

    public void dfs(int[] nums, int count) {
        //end condition
        if (set.size() == nums.length) {
            ans.add(new ArrayList(base));
            return;
        }
        if (count == nums.length) { return; }

        //backTrace body
        for (int i = 0; i < nums.length; i++) {
            if (!set.contains(nums[i])) {
                base.add(nums[i]);
                set.add(nums[i]);
                dfs(nums, count + 1);
                base.removeLast();
                set.remove(nums[i]);
            }
        }
    }
}
```

### 47. å…¨æ’åˆ—II

```java
class Solution {
    LinkedList<Integer> base = new LinkedList();
    ArrayList<List<Integer>> ans = new ArrayList();
    HashMap<Integer, Integer> map = new HashMap();
    HashMap<Integer, Integer> table = new HashMap();
    HashSet<Integer> set = new HashSet();
    HashSet<List<Integer>> dup = new HashSet();
    public List<List<Integer>> permuteUnique(int[] nums) {
        for (int n : nums) {
            table.put(n, table.getOrDefault(n, 0) + 1);
        }
        dfs(nums, 0);
        return ans;
    }

    public void dfs(int[] nums, int count) {
        //end condition
        if (count == nums.length) {
            if (!dup.contains(base)) {
                ans.add(new ArrayList(base));
                dup.add(new ArrayList(base));
            }
            return;    
        }

        //backTrace body
        for (int i = 0; i < nums.length; i++) {
            if (!map.containsKey(nums[i]) || table.get(nums[i]) != map.get(nums[i])) {
                base.add(nums[i]);
                map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);
                dfs(nums, count + 1);
                base.removeLast();
                map.put(nums[i], map.get(nums[i]) - 1);
            }
        }
    }
}
```

```java
class Solution {
    //å­˜æ”¾ç»“æœ
    List<List<Integer>> result = new ArrayList<>();
    //æš‚å­˜ç»“æœ
    List<Integer> path = new ArrayList<>();

    public List<List<Integer>> permuteUnique(int[] nums) {
        boolean[] used = new boolean[nums.length];
        Arrays.fill(used, false);
        Arrays.sort(nums);
        backTrack(nums, used);
        return result;
    }

    private void backTrack(int[] nums, boolean[] used) {
        if (path.size() == nums.length) {
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            // used[i - 1] == trueï¼Œè¯´æ˜åŒâ¼€æ ‘â½€nums[i - 1]ä½¿â½¤è¿‡
            // used[i - 1] == falseï¼Œè¯´æ˜åŒâ¼€æ ‘å±‚nums[i - 1]ä½¿â½¤è¿‡
            // å¦‚æœåŒâ¼€æ ‘å±‚nums[i - 1]ä½¿â½¤è¿‡åˆ™ç›´æ¥è·³è¿‡
            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {
                continue;
            }
            //å¦‚æœåŒâ¼€æ ‘â½€nums[i]æ²¡ä½¿â½¤è¿‡å¼€å§‹å¤„ç†
            if (used[i] == false) {
                used[i] = true;//æ ‡è®°åŒâ¼€æ ‘â½€nums[i]ä½¿â½¤è¿‡ï¼Œé˜²æ­¢åŒä¸€æ ‘æ”¯é‡å¤ä½¿ç”¨
                path.add(nums[i]);
                backTrack(nums, used);
                path.remove(path.size() - 1);//å›æº¯ï¼Œè¯´æ˜åŒâ¼€æ ‘å±‚nums[i]ä½¿â½¤è¿‡ï¼Œé˜²æ­¢ä¸‹ä¸€æ ‘å±‚é‡å¤
                used[i] = false;//å›æº¯
            }
        }
    }
}

ä½œè€…ï¼šcarlsun-2
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/permutations-ii/solution/dai-ma-sui-xiang-lu-dai-ni-xue-tou-hui-s-ki1h/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

### 332. é‡æ–°å®‰æ’è¡Œç¨‹

```java

```

### 51. Nçš‡å

```java

```

### 37. è§£æ•°ç‹¬

```java

```

&nbsp;

---

&nbsp;

## ğŸ’¯è´ª å¿ƒ

&nbsp;

### 455. åˆ†å‘é¥¼å¹²

```java
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        int count = 0;
        int j = 0;
        for (int i = 0; i < s.length && j < g.length; i++) {
            if (s[i] >= g[j]) {
                count++;
                j++;
            }
        }
        return count;
    }
}
```

### 376. æ‘†åŠ¨åºåˆ—

å°è¯•å›æº¯ï¼Œ **è¶…æ—¶**ï¼š

```java
class Solution {
    int max = 0;
    public int wiggleMaxLength(int[] nums) {
        dfs(nums, 0, -1, -1, 0);
        return max;
    }
    //n2: ä¸Šä¸€ä½ ç¬¦åˆæ¡ä»¶çš„ ç´¢å¼•, -1 è¡¨ç¤ºæ— 
    //n1: ä¸Šä¸Šä¸€ä½ç¬¦åˆæ¡ä»¶çš„ç´¢å¼•, -1 è¡¨ç¤ºæ— 
    //index: å½“å‰ç´¢å¼•
    //count: ç¬¦åˆæ¡ä»¶çš„åºåˆ—é•¿åº¦
    public void dfs(int[] nums, int index, int n2, int n1, int count) {
        
        //end condition
        if (index == nums.length) {
            max = max < count ? count : max;
            return;
        }
        //å‰ªæ
        if (count + nums.length - index < max) {
            return;
        }

        //backTrace
        //n2 == -1ï¼Œåºåˆ—ä¸ºç©º
        if (n2 == -1) {
            dfs(nums, index + 1, index, -1, 1);
            dfs(nums, index + 1, -1, -1, 0);
        }
        else {
            //n1 == -1ï¼Œåºåˆ—åªæœ‰ä¸€ä½
            if (n1 == -1) {
                //åºåˆ—æ·»åŠ ç¬¬äºŒä½æ—¶ åªéœ€è¦ä¸ç¬¬ä¸€ä½ä¸ç›¸ç­‰å³å¯
                if (nums[n2] != nums[index]) {
                    dfs(nums, index + 1, index, n2, 2);
                }
            dfs(nums, index + 1, n2, -1, 1);

            }
            //index çš„å‰ä¸¤ä½å·®å€¼ä¸ºæ­£æ•°
            else if (nums[n2] - nums[n1] > 0) {
                if (nums[index] - nums[n2] < 0) {
                    dfs(nums, index + 1, index, n2, count + 1);
                }
                dfs(nums, index + 1, n2, n1, count);
            }
            //index çš„å‰ä¸¤ä½å·®å€¼ä¸ºè´Ÿæ•°
            else if (nums[n2] - nums[n1] < 0) {
                if (nums[index] - nums[n2] > 0) {
                    dfs(nums, index + 1, index, n2, count + 1);
                }
                dfs(nums, index + 1, n2, n1, count);
            }
        }
    }
}
```

* å†…å­˜è¶…å‡ºé™åˆ¶

```java
class Solution {
    Queue<boolean[]> que = new LinkedList();
    public int wiggleMaxLength(int[] nums) {
        boolean[] isMark = new boolean[nums.length];
        Arrays.fill(isMark, true);
        que.add(isMark);
        return bfs(nums);
    }

    public int bfs(int[] nums) {
        int count = 0;
        while (!que.isEmpty()) {
            boolean[] cur = que.remove();
            //å·²æ‰¾åˆ°
            if (isWiggle(nums, cur)) {
                count = 0;
                for (boolean mark : cur) {
                    if (mark) { count++; }
                }
                return count;
            }
            //è¯¥ç»„åˆcurä¸æ˜¯ç­”æ¡ˆï¼Œåœ¨curåŸºç¡€ä¸Šæ·»åŠ ä¸‹ä¸€å±‚çš„ isMark è¡¨
            for (int i = 0; i < nums.length; i++) {
                if (cur[i]) {
                    boolean[] tmp = Arrays.copyOf(cur, cur.length);
                    tmp[i] = false;
                    que.add(tmp);
                }
            }
        }
        return count;
    }

    public boolean isWiggle(int[] nums, boolean[] isMark) {
        int n1 = -1;
        int n2 = -1;
        //get first index
        for (int i = 0; i < isMark.length; i++) {
            //find first n1
            if (n1 == -1) {
                if (isMark[i]) {
                    n1 = i;
                    continue;
                }
            }
            //find first n2
            else if (n2 == -1) {
                if (isMark[i]) {
                    n2 = i;
                    break;
                }
            }            
        }
        if (n2 == -1) { return true; }
        else if (nums[n1] == nums[n2]) { return false; }

        for (int i = n2 + 1; i < isMark.length; i++) {
            if (isMark[i]) {
                if (nums[i] == nums[n2]) { return false; }
                if (nums[n2] > nums[n1] && nums[i] > nums[n2]) {
                    return false;
                }
                if (nums[n2] < nums[n1] && nums[i] < nums[n2]) {
                    return false;
                }
                n1 = n2;
                n2 = i;
            }
        }
        return true;
    }
}
```

### 53. æœ€å¤§å­åºå’Œ

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int len = nums.length;
        if (len == 1) { return nums[0]; }

        int[] comb = new int[len];
        int index = 0;
        for (int i = 0; i < len; i++) {
            if (nums[i] == 0) {
                for (i; i < len; i++) {
                    if (nums[i] == 0) {
                        continue;
                    }
                    else {
                        comb[index++] = 0;
                        i--;
                    }
                }
            }
            else if (nums[i] > 0) {
               int sum = nums[i];
               for (i; i < len; i++) {
                   if (nums[i] >= 0) {
                       sum += nums[i];
                   }
                   else {
                       comb[index++] = sum;
                       i--;
                       continue;
                   }
               }
            }
            else if (nums[i] < 0) {
                int sum = nums[i];
                for (i; i < len; i++) {
                    if (nums[i] < 0) {
                        sum += nums[i];
                   }
                   else {
                       comb[index++] = sum;
                       i--;
                       continue;
                   }
               }
            }
        }
         int max = comb[0];
         int start = 0;
        if (comb[start] == 0) {
                i++;
                j++;
                if (comb[start] < 0) {
                    i++;
                    j++;
                }
            }
         for (int i = 0, int j = 0; i <= index, j <= index; i++, j++) {
            
        }



    }
}
```

è¶…æ—¶

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int len = nums.length;
        if (len == 1) { return nums[0]; }
        
        int max = nums[0];
        int[] comb = new int[len];
        int index = 0;
        //æ±‚å’Œï¼šå°†ç›¸é‚»æ­£æ•°åˆå¹¶ä¸ºä¸€ä¸ªæ•°ï¼Œç›¸é‚»è´Ÿæ•°åˆå¹¶ä¸ºä¸€ä¸ªæ•°
        for (int i = 0; i < len; i++) {
            if (nums[i] == 0) {
                for ( ; i < len; i++) {
                    if (nums[i] == 0) {
                        max = Math.max(nums[i], max);
                        continue;
                    }
                    else {
                        comb[index] = 0;
                        index++;
                        i--;
                        break;
                    }
                }
            }
            else if (nums[i] > 0) {
                for ( ; i < len; i++) {
                    if (nums[i] >= 0) {
                        comb[index] += nums[i];
                        max = Math.max(nums[i], max);
                    }
                    else {
                        index++;
                        i--;
                        break;
                   }
               }
            }
            else if (nums[i] < 0) {
                for ( ; i < len; i++) {
                    if (nums[i] < 0) {
                        comb[index] += nums[i];
                        max = Math.max(nums[i], max);
                    }
                    else {
                        index++;
                        i--;
                        break;
                    }
                }
            }
        }

        int sum;
        for (int i = 0; i <= index; i++) {
            sum = 0;
            for (int j = i; j <= index; j++) {
                sum += comb[j];
                max = Math.max(sum, max);
            }
        }
        return max;
    }
}
```

DP

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int len = nums.length;
        if (len == 1) { return nums[0]; }

        int[] dp = new int[len];
        dp[0] = nums[0];
        int sum = nums[0];
        for (int i = 1; i < len; i++) {
            dp[i] = Math.max(nums[i] + dp[i - 1], nums[i]);
        }
        int max = dp[0];
        for (int x : dp) {
            max = Math.max(max, x);
        }
        return max;
    }
}
```

### 122. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºII

```java
class Solution {
    public int maxProfit(int[] prices) {
        int len = prices.length;
        if (len == 1) { return 0; }
        //åˆ¤æ–­æ˜¯ä¸ºå¦å•è°ƒé€’å‡æ•°ç»„
        boolean isDes = true;
        for (int i = 1; i < len; i++) {
            if (prices[i] > prices[i - 1]) {
                isDes = false;
                break;
            }
        }
        //å•è°ƒé€’å‡ æœ€å¤§åˆ©æ¶¦ä¸º0
        if (isDes) { return 0; }

        //earning[] è¡¨ç¤º ä»Šå¤©æ¯”ä¸Šä¸€å¤©çš„æ”¶ç›Š
        int[] earning = new int[len];
        earning[0] = 0;
        int sum = 0;
        for (int i = 1; i < len; i++) {
            //è®°å½•æ‰€æœ‰çš„æ¯”ä¸Šä¸€å¤©å¤§çš„å·®å€¼ è‹¥å°äº åˆ™å–æ‰ æ•…ä¸ç”¨è®°å½•åˆ°sumä¸­
            if (prices[i] >= prices[i - 1]) {
                earning[i] = prices[i] - prices[i - 1];
                sum += earning[i];
            }
        }
        return sum;
    }
}
```

### 55. è·³è·ƒæ¸¸æˆ

```java
class Solution {
    public boolean canJump(int[] nums) {
        int len = nums.length;
        if (len == 1) { return true; }
        int curLong = 0;
        int max = 0;
        for (int i = 0; i < len; i++) {
            //
            if (max >= i) {
                curLong = nums[i] + i;
                max = Math.max(max, curLong);
            }
            else {
                return false;
            }
        }
        return true;
    }
}
```

### 45. è·³è·ƒæ¸¸æˆII

```java
class Solution {
    public int jump(int[] nums) {
        int len = nums.length;
        if (len == 1) { return 0; }
        int max = nums[0];
        int curMax = nums[0];
        int count = 1;
        if (max >= len) { return 1; }
        
        int i = 0;
        while (max < len - 1) {
            for (int j = i; j <= max; j++) {
                if (nums[j] + j > curMax) {
                    curMax = nums[j] + j;
                    i = j;
                }
            }
            max = curMax;
            count++;
        }
        return count;
    }
}
```

* å®˜æ–¹

```java
class Solution {
    public int jump(int[] nums) {
        int length = nums.length;
        int end = 0;
        int maxPosition = 0; 
        int steps = 0;
        for (int i = 0; i < length - 1; i++) {
            maxPosition = Math.max(maxPosition, i + nums[i]); 
            if (i == end) {
                end = maxPosition;
                steps++;
            }
        }
        return steps;
    }
}

ä½œè€…ï¼šLeetCode-Solution
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/jump-game-ii/solution/tiao-yue-you-xi-ii-by-leetcode-solution/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

### 134. åŠ æ²¹ç«™

```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int len = gas.length;
        int[] tank = new int[len];

        tank[0] = gas[0] - cost[0];
        int minIndex = 0;
        int minTank = tank[0];

        if (len == 1) {
            if (tank[0] < 0) { return -1; }
            else { return 0; }
        }
        
        for (int i = 1; i < len; i++) {
            tank[i] = tank[i - 1] + gas[i] - cost[i];
            if (minTank >= tank[i]) {
                minTank = tank[i];
                minIndex = i;
            }
        }

        //minTank >= tank[i]: æœ‰ç›¸åŒçš„æœ€å°å€¼ åˆ™å–é åçš„ ï¼ˆå› ä¸ºç­”æ¡ˆå”¯ä¸€ æ‰€ä»¥é å‰çš„minTank=0 æ— æ³•ç»§ç»­å‘å‰è¡Œé©¶ï¼‰
        //å¾—åˆ°çš„ minIndex å³ä¸º å”¯ä¸€å¯èƒ½ çš„ç»ˆç‚¹

        //ä¸¤ç§æƒ…å†µï¼š1. ç»ˆç‚¹è‹¥ä¸ºæœ€åä¸€ä¸ªåŠ æ²¹ç«™
        if (minIndex == len - 1) {
            for (int i = 1; i < len - 1; i++) {
                if (tank[i] <= 0) {
                    return -1;
                }
            }
            if (tank[len - 1] < 0) {
                return -1;
            }
            else {
                return 0;
            }
        }
        //2. å¦‚æœç»ˆç‚¹åœ¨é™¤äº†æœ€åä¸€ä¸ªåŠ æ²¹ç«™ä»¥å¤–çš„å…¶ä»–åŠ æ²¹ç«™
        else {
            if (tank[len - 1] < 0) {
                return -1;
            }
            for (int i = 0; i < len - 1; i++) {
                if (i != minIndex && i != minIndex + 1 && tank[i] == minTank) {
                    return - 1;
                }
            }
            return minIndex + 1;
        }
    }
}
```

### 135. åˆ†å‘ç³–æœ

```java
class Solution {
    int[] cans;
    int len;
    public int candy(int[] ratings) {
        len = ratings.length;
        cans = new int[len];
        Arrays.fill(cans, 0);
        for (int i = 0; i < len; i++) {
            setCandy(ratings, i);
        }
        int sum = 0;
        for (int v : cans) {
            sum += v;
        }
        return sum;
    }

    public void setCandy(int[] ratings, int index) {
        //è¯¥å­©å­å·²è®¾ç½®è¿‡ç³–æœæ•° åˆ™è·³è¿‡
        if (cans[index] != 0) { return; }
        int ans = 1;
        
        //æ¯”è¾ƒä¸å·¦å³çš„è¯„åˆ†é«˜ä½ï¼Œè‹¥æ¯”å·¦å³é«˜ åˆ™å…ˆè®¾ç½®å·¦å³å­©å­ç³–æœæ•°
        //ä¸å·¦è¾¹æ¯”è¾ƒ
        if (index > 0) {
            if (ratings[index] > ratings[index - 1]) {
                setCandy(ratings, index - 1);
                ans = Math.max(cans[index - 1] + 1, ans);
            }
        }
        //ä¸å³è¾¹æ¯”è¾ƒ
        if (index < len - 1) {
            if (ratings[index] > ratings[index + 1]) {
                setCandy(ratings, index + 1);
                ans = Math.max(cans[index + 1] + 1, ans);
            }
        }
        cans[index] = ans;
    }
}
```

### 860. æŸ æª¬æ°´æ‰¾é›¶

```java
class Solution {
    public boolean lemonadeChange(int[] bills) {
        int m5 = 0;
        int m10 = 0;
        int m20 = 0;
        
        for (int v : bills) {
            // 5
            if (v == 5) {
                m5++;
            }
            // 10
            else if (v == 10) {
                //å…ˆç»™10æ‰¾é›¶
                if (m5 < 1) {
                    return false;
                }
                else {
                    m5--;
                    m10++;
                }
            }
            // 20
            else {
                //ç»™20æ‰¾é›¶ (ç»™20æ‰¾é›¶ 5å…ƒå……è¶³çš„è¯å¯ä»¥æ²¡æœ‰10å…ƒ ä½†ä¸èƒ½æ²¡æœ‰5å…ƒ)
                // æœ‰10å…ƒ
                if (m10 >= 1) {
                    if (m5 >= 1) {
                        m10--;
                        m5--;
                    }
                    else { return false; }
                }
                //æ²¡10å…ƒ
                else {
                    if (m5 >= 3) {
                        m5 -= 3;
                    }
                    else { return false; }
                }
            }
        }
        return true;
    }
}
```

### 435. æ— é‡å åŒºé—´

```java
class Solution {
    //è¡¨ç¤ºè¯¥åŒºé—´æ˜¯å¦è¿˜æœªåˆ é™¤
    boolean[] isExist;
    int len;
    //å½“å‰åˆ é™¤åŒºé—´æ•°
    int delCount;
    //æœ€å°‘åˆ é™¤åŒºé—´æ•° ä¸ºè¯¥é¢˜çš„è¿”å›å€¼
    int minDel;

    boolean[][] lapTable;

    public int eraseOverlapIntervals(int[][] intervals) {
        len = intervals.length;
        isExist = new boolean[len];
        Arrays.fill(isExist, true);
        delCount = 0;
        minDel = len;
        //å­˜å‚¨æ¯ä¸ªåŒºé—´ç›¸äº’æ˜¯å¦é‡å 
        lapTable = new boolean[len][len];
        for (int i = 0; i < len; i++) {
            for (int j = i; j < len; j++) {
                boolean isLap = isOverlap(intervals, i, j);
                lapTable[i][j] = isLap;
                lapTable[j][i] = isLap;
            }
        }

        dfs(intervals, 0);
        return minDel;
    }

    public void dfs(int[][] intervals, int start) {
        //å‰ªæ
        if (minDel <= delCount + 1) { return; }
        //ç»ˆæ­¢
        if (start == len) {
            boolean hasOverlap = false;
            for (int i = 0; i < len; i++) {
                if (!isExist[i]) { continue; }
                for (int j = i + 1; j < len; j++) {
                    if (j == i || !isExist[j]) { continue; }
                    if (lapTable[i][j]) {
                        hasOverlap = true;
                        break;
                    }
                }
                if (hasOverlap) { break; }
            }

            //å›æº¯ç»ˆæ­¢æ¡ä»¶
            if (!hasOverlap) {
                minDel = Math.min(minDel, delCount);
                // System.out.println(Arrays.toString(isExist));
            }
            return;
        }

        //å‰ªæ
        //æ‰¾å‡ºä»startç´¢å¼•å¼€å§‹ ç¬¬ä¸€ä¸ªä¸å…¶ä»–åŒºé—´æœ‰é‡å çš„ç´¢å¼•
        int nextIndex = start;
        boolean isFoundNext = false;
        for (int i = start; i < len; i++) {
            if (!isExist[i]) { continue; }
            for (int j = 0; j < len; j++) {
                if (j == i || !isExist[j]) { continue; }
                if (lapTable[i][j]) {
                    isFoundNext = true;
                    nextIndex = i;
                    break;
                }
            }
            if (isFoundNext) { break; }
        }

        //backtrace body
        if (isFoundNext) {
            isExist[nextIndex] = false;
            delCount++;
            dfs(intervals, nextIndex + 1);
            isExist[nextIndex] = true;
            delCount--;
            dfs(intervals, nextIndex + 1);
        }
    }

    //è®¡ç®—ä¸¤ä¸ªåŒºé—´æ˜¯å¦é‡å 
    public boolean isOverlap(int[][] intervals, int a, int b) {
        if (intervals[a][0] <= intervals[b][0] && intervals[a][1] <= intervals[b][0]) {
            return false;
        }
        if (intervals[a][0] >= intervals[b][1] && intervals[a][1] >= intervals[b][1]) {
            return false;
        }
        return true;
    }
}
```

Compare æ’åº Comparator

```java
Arrays.sort(intervals, new Comparator<int[]>() {
    public int compare(int[] intervals1, int[] intervals2) {
        return intervals1[0] - intervals2[0];
    }
});
```

### 763. åˆ’åˆ†å­—æ¯åŒºé—´

```java
class Solution {
    public List<Integer> partitionLabels(String s) {
        List<Integer> ans = new LinkedList();
        int len = s.length();
        //éå†ä¸€é s ï¼Œå°†æ‰€æœ‰å­—ç¬¦å­˜å…¥ HashMapï¼Œ valueè¡¨ç¤ºå‡ºç°æ¬¡æ•°
        HashMap<Character, Integer> remain = new HashMap();
        for (int i = 0; i < len; i++) {
            remain.put(s.charAt(i), remain.getOrDefault(s.charAt(i), 0) + 1);
        }

        for (int start = 0; start < len; start++) {
            HashSet<Character> curSet = new HashSet();
            int count = 0;
            for (int i = start; i < len; i++) {
                char tmp = s.charAt(i);
                curSet.add(tmp);
                remain.put(tmp, remain.getOrDefault(tmp, 0) - 1);
                count++;
                if (isLastOne(curSet, remain)) {
                    ans.add(count);
                    start = i;
                    break;
                }
            }
        }
        return ans;
    }
    
    //åˆ¤æ–­å‰©ä½™é›†åˆ remain ä¸­æ˜¯å¦è¿˜å«æœ‰å½“å‰å­—æ¯
    public boolean isLastOne(HashSet<Character> curSet, HashMap<Character, Integer> remain) {
        for (Character v : curSet) {
            if (remain.get(v) > 0) {
                return false;
            }
        }
        return true;
    }
}
```

### 56. åˆå¹¶åŒºé—´

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        int len = intervals.length;
        Arrays.sort(intervals, new Comparator<int[]>() {
            public int compare(int[] inter1, int[] inter2) {
                return inter1[0] - inter2[0];
            }
        });
        //åˆå§‹åŒ–
        int[][] ans = new int[len][2];
        int ansIndex = 0;
        int left = intervals[0][0];
        int right = intervals[0][1];
        ans[ansIndex][0] = left;
        ans[ansIndex][1] = right;

        //
        for (int i = 1; i < len; i++) {
            //ä¸ä¸Šä¸€ä¸ªansåŒºé—´æ— é‡å 
            if (intervals[i][0] > right) {
                ansIndex++;
                ans[ansIndex][0] = intervals[i][0];
                ans[ansIndex][1] = intervals[i][1];
                left = intervals[i][0];
                right = intervals[i][1];
            }
            //æœ‰é‡å 
            else {
                right = Math.max(right, intervals[i][1]);
                ans[ansIndex][1] = right;
            }
        }
        return Arrays.copyOfRange(ans, 0, ansIndex + 1);
    }
}
```

&nbsp;

---

&nbsp;

## ğŸ“¡åŠ¨ æ€ è§„ åˆ’

* **ã€TODOã€‘**

&nbsp;

---

&nbsp;

## ğŸ§©å›¾ è®º

* **ã€TODOã€‘**

&nbsp;

---

&nbsp;

## ğŸ¯é«˜ çº§ æ•° æ® ç»“ æ„

* **ã€TODOã€‘**
